// Copyright Antimetal, Inc. All rights reserved.
//
// Use of this source code is governed by a source available license that can be found in the
// LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type Config struct {
	InputFile  string
	OutputFile string
	Package    string
}

type StructField struct {
	Name     string
	CType    string
	GoType   string
	Size     int
	IsArray  bool
	ArrayLen int
	Comment  string
}

type Struct struct {
	Name   string
	Fields []StructField
}

type Constant struct {
	Name  string
	Value string
}

type FileData struct {
	Package      string
	InputFile    string
	Structs      []Struct
	Constants    []Constant
	SourceHeader string
}

const goTemplate = `// Code generated by ebpf-typegen. DO NOT EDIT.
// Source: {{ .InputFile }}

// Copyright Antimetal, Inc. All rights reserved.
//
// Use of this source code is governed by a source available license that can be found in the
// LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

package {{ .Package }}

// NOTE: These structs match the binary layout of GPL-licensed BPF code.
// The Go code itself is NOT derived from GPL code - it merely provides
// compatible data structures for kernel communication.

{{- if .Constants }}

// Constants matching BPF definitions
const (
{{- range .Constants }}
	{{ .Name }} = {{ .Value }}
{{- end }}
)
{{- end }}

{{- range .Structs }}

// {{ .Name }} matches the C struct layout from the GPL BPF code.
// This Go struct is NOT derived from GPL code - it merely matches the binary layout
// for data exchange purposes. The data structure layout itself is not copyrightable.
type {{ .Name }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .GoType }}{{ if .Comment }} // {{ .Comment }}{{ end }}
{{- end }}
}
{{- end }}
`

var (
	cToGoTypes = map[string]string{
		"__s32":    "int32",
		"__u32":    "uint32",
		"__s64":    "int64",
		"__u64":    "uint64",
		"__s16":    "int16",
		"__u16":    "uint16",
		"__s8":     "int8",
		"__u8":     "uint8",
		"char":     "byte",
		"int":      "int32",
		"unsigned": "uint32",
	}

	// Known constants for array sizes
	knownConstants = map[string]int{
		"TASK_COMM_LEN":      16,
		"ARGSIZE":            128,
		"TOTAL_MAX_ARGS":     60,
		"FULL_MAX_ARGS_ARR":  60 * 128,
	}

	titleCase = cases.Title(language.English)

	// Pre-compiled regex patterns for performance
	defineRe = regexp.MustCompile(`#define\s+([A-Z_]+)\s+(\d+)`)
	structRe = regexp.MustCompile(`(?s)struct\s+(\w+)\s*\{([^}]+)\}`)
	arrayRe  = regexp.MustCompile(`^(\S+)\s+(\w+)\[(\w+)\]$`)
	fieldRe  = regexp.MustCompile(`^(\S+)\s+(\w+)$`)
)

func main() {
	var cfg Config
	flag.StringVar(&cfg.InputFile, "input", "", "Input C header file")
	flag.StringVar(&cfg.OutputFile, "output", "", "Output Go file")
	flag.StringVar(&cfg.Package, "package", "collectors", "Go package name")
	flag.Parse()

	if cfg.InputFile == "" || cfg.OutputFile == "" {
		flag.Usage()
		log.Fatal("Both -input and -output flags are required")
	}

	if err := generate(cfg); err != nil {
		log.Fatal(err)
	}
}

func generate(cfg Config) error {
	content, err := os.ReadFile(cfg.InputFile)
	if err != nil {
		return fmt.Errorf("reading input file: %w", err)
	}

	data := FileData{
		Package:   cfg.Package,
		InputFile: filepath.Base(cfg.InputFile),
	}

	// Parse constants
	data.Constants = parseConstants(string(content))

	// Parse structs
	data.Structs = parseStructs(string(content))

	// Generate Go code
	tmpl, err := template.New("go").Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Write unformatted for debugging
		if err := os.WriteFile(cfg.OutputFile, buf.Bytes(), 0644); err != nil {
			return fmt.Errorf("writing output file: %w", err)
		}
		return fmt.Errorf("formatting generated code: %w", err)
	}

	// Write output
	if err := os.WriteFile(cfg.OutputFile, formatted, 0644); err != nil {
		return fmt.Errorf("writing output file: %w", err)
	}

	fmt.Printf("Generated %s from %s\n", cfg.OutputFile, cfg.InputFile)
	return nil
}

func parseConstants(content string) []Constant {
	var constants []Constant

	// Match #define NAME VALUE patterns where VALUE is a number
	matches := defineRe.FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		name := match[1]
		value := match[2]

		// Skip header guards
		if strings.HasSuffix(name, "_H") || strings.HasPrefix(name, "__") {
			continue
		}

		// Convert C-style names to Go-style
		goName := toCamelCase(name)
		constants = append(constants, Constant{
			Name:  goName,
			Value: value,
		})
	}

	// Also handle expressions like (TOTAL_MAX_ARGS * ARGSIZE)
	// For now, we'll skip these as they need evaluation

	return constants
}

func parseStructs(content string) []Struct {
	var structs []Struct

	// Match struct definitions - use (?s) flag to make . match newlines
	matches := structRe.FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		structName := match[1]
		body := match[2]

		s := Struct{
			Name: toGoStructName(structName),
		}

		// Parse fields
		lines := strings.Split(body, "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if line == "" || strings.HasPrefix(line, "//") || strings.HasPrefix(line, "/*") || strings.HasPrefix(line, "*") {
				continue
			}

			if field := parseField(line); field != nil {
				s.Fields = append(s.Fields, *field)
			}
		}

		if len(s.Fields) > 0 {
			structs = append(structs, s)
		}
	}

	return structs
}

func parseField(line string) *StructField {
	// Remove comments
	if idx := strings.Index(line, "//"); idx >= 0 {
		line = line[:idx]
	}
	line = strings.TrimSpace(line)

	// Skip empty lines or lines without semicolon
	if line == "" || !strings.HasSuffix(line, ";") {
		return nil
	}

	// Remove semicolon
	line = strings.TrimSuffix(line, ";")
	line = strings.TrimSpace(line)

	// Match array fields: type name[size] where size can be a number or constant
	if matches := arrayRe.FindStringSubmatch(line); matches != nil {
		cType := matches[1]
		name := matches[2]
		sizeStr := matches[3]

		// Try to parse as number, otherwise look up constant
		size, err := strconv.Atoi(sizeStr)
		if err != nil {
			// Look up known constants
			if knownSize, ok := knownConstants[sizeStr]; ok {
				size = knownSize
			} else {
				if _, err := fmt.Fprintf(os.Stderr, "Warning: Unknown array size constant: %s\n", sizeStr); err != nil {
					// Log error but continue processing
					log.Printf("Failed to write warning to stderr: %v", err)
				}
				return nil
			}
		}

		goType := cToGoType(cType)
		return &StructField{
			Name:     toGoFieldName(name),
			CType:    cType,
			GoType:   fmt.Sprintf("[%d]%s", size, goType),
			IsArray:  true,
			ArrayLen: size,
		}
	}

	// Match regular fields: type name
	if matches := fieldRe.FindStringSubmatch(line); matches != nil {
		cType := matches[1]
		name := matches[2]

		return &StructField{
			Name:   toGoFieldName(name),
			CType:  cType,
			GoType: cToGoType(cType),
		}
	}

	// If we couldn't parse, log it for debugging
	if line != "" {
		if _, err := fmt.Fprintf(os.Stderr, "Warning: Could not parse field: %q\n", line); err != nil {
			// Log error but continue processing
			log.Printf("Failed to write warning to stderr: %v", err)
		}
	}

	return nil
}

func cToGoType(cType string) string {
	if goType, ok := cToGoTypes[cType]; ok {
		return goType
	}
	// Default to keeping the type as-is
	return cType
}

func toCamelCase(s string) string {
	// Handle special constants
	switch s {
	case "ARGSIZE":
		return "ArgSize"
	case "FULL_MAX_ARGS_ARR":
		return "FullMaxArgsArr"
	}

	parts := strings.Split(strings.ToLower(s), "_")
	for i, part := range parts {
		if part != "" {
			parts[i] = titleCase.String(part)
		}
	}
	return strings.Join(parts, "")
}

func toGoFieldName(s string) string {
	// Handle special cases first
	switch strings.ToLower(s) {
	case "pid":
		return "PID"
	case "ppid":
		return "PPID"
	case "uid":
		return "UID"
	case "gid":
		return "GID"
	case "tid":
		return "TID"
	case "retval":
		return "RetVal"
	}

	// Convert snake_case to CamelCase
	name := toCamelCase(s)

	return name
}

func toGoStructName(s string) string {
	// Remove _event suffix if present
	s = strings.TrimSuffix(s, "_event")

	// Convert to CamelCase
	camel := ""
	parts := strings.Split(s, "_")
	for _, part := range parts {
		if part != "" {
			// Keep uppercase parts (like SNOOP) as-is
			if part == strings.ToUpper(part) {
				camel += titleCase.String(strings.ToLower(part))
			} else {
				camel += titleCase.String(part)
			}
		}
	}

	// Add Event suffix
	return camel + "Event"
}
