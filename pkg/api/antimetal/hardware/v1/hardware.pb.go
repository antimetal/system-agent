// Antimetal API definitions
// Copyright Antimetal, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: antimetal/hardware/v1/hardware.proto

package hardwarev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Architecture represents system architectures following uname conventions
type Architecture int32

const (
	Architecture_ARCHITECTURE_UNKNOWN  Architecture = 0
	Architecture_ARCHITECTURE_X86      Architecture = 1
	Architecture_ARCHITECTURE_X86_64   Architecture = 2
	Architecture_ARCHITECTURE_ARM      Architecture = 3
	Architecture_ARCHITECTURE_ARM64    Architecture = 4
	Architecture_ARCHITECTURE_PPC      Architecture = 5
	Architecture_ARCHITECTURE_PPC64    Architecture = 6
	Architecture_ARCHITECTURE_PPC64LE  Architecture = 7
	Architecture_ARCHITECTURE_S390     Architecture = 8
	Architecture_ARCHITECTURE_S390X    Architecture = 9
	Architecture_ARCHITECTURE_MIPS     Architecture = 10
	Architecture_ARCHITECTURE_MIPS64   Architecture = 11
	Architecture_ARCHITECTURE_MIPS64LE Architecture = 12
	Architecture_ARCHITECTURE_RISCV64  Architecture = 13
	Architecture_ARCHITECTURE_SPARC    Architecture = 14
	Architecture_ARCHITECTURE_SPARC64  Architecture = 15
)

// Enum value maps for Architecture.
var (
	Architecture_name = map[int32]string{
		0:  "ARCHITECTURE_UNKNOWN",
		1:  "ARCHITECTURE_X86",
		2:  "ARCHITECTURE_X86_64",
		3:  "ARCHITECTURE_ARM",
		4:  "ARCHITECTURE_ARM64",
		5:  "ARCHITECTURE_PPC",
		6:  "ARCHITECTURE_PPC64",
		7:  "ARCHITECTURE_PPC64LE",
		8:  "ARCHITECTURE_S390",
		9:  "ARCHITECTURE_S390X",
		10: "ARCHITECTURE_MIPS",
		11: "ARCHITECTURE_MIPS64",
		12: "ARCHITECTURE_MIPS64LE",
		13: "ARCHITECTURE_RISCV64",
		14: "ARCHITECTURE_SPARC",
		15: "ARCHITECTURE_SPARC64",
	}
	Architecture_value = map[string]int32{
		"ARCHITECTURE_UNKNOWN":  0,
		"ARCHITECTURE_X86":      1,
		"ARCHITECTURE_X86_64":   2,
		"ARCHITECTURE_ARM":      3,
		"ARCHITECTURE_ARM64":    4,
		"ARCHITECTURE_PPC":      5,
		"ARCHITECTURE_PPC64":    6,
		"ARCHITECTURE_PPC64LE":  7,
		"ARCHITECTURE_S390":     8,
		"ARCHITECTURE_S390X":    9,
		"ARCHITECTURE_MIPS":     10,
		"ARCHITECTURE_MIPS64":   11,
		"ARCHITECTURE_MIPS64LE": 12,
		"ARCHITECTURE_RISCV64":  13,
		"ARCHITECTURE_SPARC":    14,
		"ARCHITECTURE_SPARC64":  15,
	}
)

func (x Architecture) Enum() *Architecture {
	p := new(Architecture)
	*p = x
	return p
}

func (x Architecture) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Architecture) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_hardware_v1_hardware_proto_enumTypes[0].Descriptor()
}

func (Architecture) Type() protoreflect.EnumType {
	return &file_antimetal_hardware_v1_hardware_proto_enumTypes[0]
}

func (x Architecture) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Architecture.Descriptor instead.
func (Architecture) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{0}
}

// InterfaceType represents network interface types
type InterfaceType int32

const (
	InterfaceType_INTERFACE_TYPE_UNKNOWN    InterfaceType = 0
	InterfaceType_INTERFACE_TYPE_ETHERNET   InterfaceType = 1
	InterfaceType_INTERFACE_TYPE_WIRELESS   InterfaceType = 2
	InterfaceType_INTERFACE_TYPE_LOOPBACK   InterfaceType = 3
	InterfaceType_INTERFACE_TYPE_VIRTUAL    InterfaceType = 4
	InterfaceType_INTERFACE_TYPE_BRIDGE     InterfaceType = 5
	InterfaceType_INTERFACE_TYPE_VLAN       InterfaceType = 6
	InterfaceType_INTERFACE_TYPE_TUN        InterfaceType = 7
	InterfaceType_INTERFACE_TYPE_TAP        InterfaceType = 8
	InterfaceType_INTERFACE_TYPE_BOND       InterfaceType = 9
	InterfaceType_INTERFACE_TYPE_INFINIBAND InterfaceType = 10
)

// Enum value maps for InterfaceType.
var (
	InterfaceType_name = map[int32]string{
		0:  "INTERFACE_TYPE_UNKNOWN",
		1:  "INTERFACE_TYPE_ETHERNET",
		2:  "INTERFACE_TYPE_WIRELESS",
		3:  "INTERFACE_TYPE_LOOPBACK",
		4:  "INTERFACE_TYPE_VIRTUAL",
		5:  "INTERFACE_TYPE_BRIDGE",
		6:  "INTERFACE_TYPE_VLAN",
		7:  "INTERFACE_TYPE_TUN",
		8:  "INTERFACE_TYPE_TAP",
		9:  "INTERFACE_TYPE_BOND",
		10: "INTERFACE_TYPE_INFINIBAND",
	}
	InterfaceType_value = map[string]int32{
		"INTERFACE_TYPE_UNKNOWN":    0,
		"INTERFACE_TYPE_ETHERNET":   1,
		"INTERFACE_TYPE_WIRELESS":   2,
		"INTERFACE_TYPE_LOOPBACK":   3,
		"INTERFACE_TYPE_VIRTUAL":    4,
		"INTERFACE_TYPE_BRIDGE":     5,
		"INTERFACE_TYPE_VLAN":       6,
		"INTERFACE_TYPE_TUN":        7,
		"INTERFACE_TYPE_TAP":        8,
		"INTERFACE_TYPE_BOND":       9,
		"INTERFACE_TYPE_INFINIBAND": 10,
	}
)

func (x InterfaceType) Enum() *InterfaceType {
	p := new(InterfaceType)
	*p = x
	return p
}

func (x InterfaceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InterfaceType) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_hardware_v1_hardware_proto_enumTypes[1].Descriptor()
}

func (InterfaceType) Type() protoreflect.EnumType {
	return &file_antimetal_hardware_v1_hardware_proto_enumTypes[1]
}

func (x InterfaceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InterfaceType.Descriptor instead.
func (InterfaceType) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{1}
}

// BusType represents hardware bus types
type BusType int32

const (
	BusType_BUS_TYPE_UNKNOWN BusType = 0
	BusType_BUS_TYPE_PCI     BusType = 1
	BusType_BUS_TYPE_PCIE    BusType = 2
	BusType_BUS_TYPE_USB     BusType = 3
	BusType_BUS_TYPE_SATA    BusType = 4
	BusType_BUS_TYPE_NVME    BusType = 5
	BusType_BUS_TYPE_SAS     BusType = 6
	BusType_BUS_TYPE_IDE     BusType = 7
	BusType_BUS_TYPE_SCSI    BusType = 8
	BusType_BUS_TYPE_VIRTIO  BusType = 9
)

// Enum value maps for BusType.
var (
	BusType_name = map[int32]string{
		0: "BUS_TYPE_UNKNOWN",
		1: "BUS_TYPE_PCI",
		2: "BUS_TYPE_PCIE",
		3: "BUS_TYPE_USB",
		4: "BUS_TYPE_SATA",
		5: "BUS_TYPE_NVME",
		6: "BUS_TYPE_SAS",
		7: "BUS_TYPE_IDE",
		8: "BUS_TYPE_SCSI",
		9: "BUS_TYPE_VIRTIO",
	}
	BusType_value = map[string]int32{
		"BUS_TYPE_UNKNOWN": 0,
		"BUS_TYPE_PCI":     1,
		"BUS_TYPE_PCIE":    2,
		"BUS_TYPE_USB":     3,
		"BUS_TYPE_SATA":    4,
		"BUS_TYPE_NVME":    5,
		"BUS_TYPE_SAS":     6,
		"BUS_TYPE_IDE":     7,
		"BUS_TYPE_SCSI":    8,
		"BUS_TYPE_VIRTIO":  9,
	}
)

func (x BusType) Enum() *BusType {
	p := new(BusType)
	*p = x
	return p
}

func (x BusType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BusType) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_hardware_v1_hardware_proto_enumTypes[2].Descriptor()
}

func (BusType) Type() protoreflect.EnumType {
	return &file_antimetal_hardware_v1_hardware_proto_enumTypes[2]
}

func (x BusType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BusType.Descriptor instead.
func (BusType) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{2}
}

// DuplexMode represents network interface duplex modes
type DuplexMode int32

const (
	DuplexMode_DUPLEX_MODE_UNKNOWN DuplexMode = 0
	DuplexMode_DUPLEX_MODE_HALF    DuplexMode = 1
	DuplexMode_DUPLEX_MODE_FULL    DuplexMode = 2
)

// Enum value maps for DuplexMode.
var (
	DuplexMode_name = map[int32]string{
		0: "DUPLEX_MODE_UNKNOWN",
		1: "DUPLEX_MODE_HALF",
		2: "DUPLEX_MODE_FULL",
	}
	DuplexMode_value = map[string]int32{
		"DUPLEX_MODE_UNKNOWN": 0,
		"DUPLEX_MODE_HALF":    1,
		"DUPLEX_MODE_FULL":    2,
	}
)

func (x DuplexMode) Enum() *DuplexMode {
	p := new(DuplexMode)
	*p = x
	return p
}

func (x DuplexMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DuplexMode) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_hardware_v1_hardware_proto_enumTypes[3].Descriptor()
}

func (DuplexMode) Type() protoreflect.EnumType {
	return &file_antimetal_hardware_v1_hardware_proto_enumTypes[3]
}

func (x DuplexMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DuplexMode.Descriptor instead.
func (DuplexMode) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{3}
}

// OperationalState represents network interface operational states
type OperationalState int32

const (
	OperationalState_OPERATIONAL_STATE_UNKNOWN          OperationalState = 0
	OperationalState_OPERATIONAL_STATE_UP               OperationalState = 1
	OperationalState_OPERATIONAL_STATE_DOWN             OperationalState = 2
	OperationalState_OPERATIONAL_STATE_TESTING          OperationalState = 3
	OperationalState_OPERATIONAL_STATE_DORMANT          OperationalState = 4
	OperationalState_OPERATIONAL_STATE_NOT_PRESENT      OperationalState = 5
	OperationalState_OPERATIONAL_STATE_LOWER_LAYER_DOWN OperationalState = 6
)

// Enum value maps for OperationalState.
var (
	OperationalState_name = map[int32]string{
		0: "OPERATIONAL_STATE_UNKNOWN",
		1: "OPERATIONAL_STATE_UP",
		2: "OPERATIONAL_STATE_DOWN",
		3: "OPERATIONAL_STATE_TESTING",
		4: "OPERATIONAL_STATE_DORMANT",
		5: "OPERATIONAL_STATE_NOT_PRESENT",
		6: "OPERATIONAL_STATE_LOWER_LAYER_DOWN",
	}
	OperationalState_value = map[string]int32{
		"OPERATIONAL_STATE_UNKNOWN":          0,
		"OPERATIONAL_STATE_UP":               1,
		"OPERATIONAL_STATE_DOWN":             2,
		"OPERATIONAL_STATE_TESTING":          3,
		"OPERATIONAL_STATE_DORMANT":          4,
		"OPERATIONAL_STATE_NOT_PRESENT":      5,
		"OPERATIONAL_STATE_LOWER_LAYER_DOWN": 6,
	}
)

func (x OperationalState) Enum() *OperationalState {
	p := new(OperationalState)
	*p = x
	return p
}

func (x OperationalState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperationalState) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_hardware_v1_hardware_proto_enumTypes[4].Descriptor()
}

func (OperationalState) Type() protoreflect.EnumType {
	return &file_antimetal_hardware_v1_hardware_proto_enumTypes[4]
}

func (x OperationalState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OperationalState.Descriptor instead.
func (OperationalState) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{4}
}

// ContainmentType represents types of containment relationships
type ContainmentType int32

const (
	ContainmentType_CONTAINMENT_TYPE_UNKNOWN   ContainmentType = 0
	ContainmentType_CONTAINMENT_TYPE_PHYSICAL  ContainmentType = 1
	ContainmentType_CONTAINMENT_TYPE_LOGICAL   ContainmentType = 2
	ContainmentType_CONTAINMENT_TYPE_PARTITION ContainmentType = 3
)

// Enum value maps for ContainmentType.
var (
	ContainmentType_name = map[int32]string{
		0: "CONTAINMENT_TYPE_UNKNOWN",
		1: "CONTAINMENT_TYPE_PHYSICAL",
		2: "CONTAINMENT_TYPE_LOGICAL",
		3: "CONTAINMENT_TYPE_PARTITION",
	}
	ContainmentType_value = map[string]int32{
		"CONTAINMENT_TYPE_UNKNOWN":   0,
		"CONTAINMENT_TYPE_PHYSICAL":  1,
		"CONTAINMENT_TYPE_LOGICAL":   2,
		"CONTAINMENT_TYPE_PARTITION": 3,
	}
)

func (x ContainmentType) Enum() *ContainmentType {
	p := new(ContainmentType)
	*p = x
	return p
}

func (x ContainmentType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ContainmentType) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_hardware_v1_hardware_proto_enumTypes[5].Descriptor()
}

func (ContainmentType) Type() protoreflect.EnumType {
	return &file_antimetal_hardware_v1_hardware_proto_enumTypes[5]
}

func (x ContainmentType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ContainmentType.Descriptor instead.
func (ContainmentType) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{5}
}

// SystemNode represents the root hardware node for a physical or virtual machine
type SystemNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hostname of the system
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Architecture following uname conventions
	Architecture Architecture `protobuf:"varint,2,opt,name=architecture,proto3,enum=antimetal.hardware.v1.Architecture" json:"architecture,omitempty"`
	// Boot time of the system
	BootTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=boot_time,json=bootTime,proto3" json:"boot_time,omitempty"`
	// Kernel version
	KernelVersion string `protobuf:"bytes,4,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	// Operating system information
	OsInfo        string `protobuf:"bytes,5,opt,name=os_info,json=osInfo,proto3" json:"os_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SystemNode) Reset() {
	*x = SystemNode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SystemNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SystemNode) ProtoMessage() {}

func (x *SystemNode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SystemNode.ProtoReflect.Descriptor instead.
func (*SystemNode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{0}
}

func (x *SystemNode) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *SystemNode) GetArchitecture() Architecture {
	if x != nil {
		return x.Architecture
	}
	return Architecture_ARCHITECTURE_UNKNOWN
}

func (x *SystemNode) GetBootTime() *timestamppb.Timestamp {
	if x != nil {
		return x.BootTime
	}
	return nil
}

func (x *SystemNode) GetKernelVersion() string {
	if x != nil {
		return x.KernelVersion
	}
	return ""
}

func (x *SystemNode) GetOsInfo() string {
	if x != nil {
		return x.OsInfo
	}
	return ""
}

// CPUPackageNode represents a physical CPU socket/package
type CPUPackageNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Socket ID (physical package ID)
	SocketId int32 `protobuf:"varint,1,opt,name=socket_id,json=socketId,proto3" json:"socket_id,omitempty"`
	// Vendor ID (e.g., GenuineIntel, AuthenticAMD)
	VendorId string `protobuf:"bytes,2,opt,name=vendor_id,json=vendorId,proto3" json:"vendor_id,omitempty"`
	// Model name (e.g., Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz)
	ModelName string `protobuf:"bytes,3,opt,name=model_name,json=modelName,proto3" json:"model_name,omitempty"`
	// CPU family
	CpuFamily int32 `protobuf:"varint,4,opt,name=cpu_family,json=cpuFamily,proto3" json:"cpu_family,omitempty"`
	// Model number
	Model int32 `protobuf:"varint,5,opt,name=model,proto3" json:"model,omitempty"`
	// Stepping
	Stepping int32 `protobuf:"varint,6,opt,name=stepping,proto3" json:"stepping,omitempty"`
	// Microcode version
	Microcode string `protobuf:"bytes,7,opt,name=microcode,proto3" json:"microcode,omitempty"`
	// Cache size
	CacheSize string `protobuf:"bytes,8,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	// Number of physical cores in this package
	PhysicalCores int32 `protobuf:"varint,9,opt,name=physical_cores,json=physicalCores,proto3" json:"physical_cores,omitempty"`
	// Number of logical cores (with hyperthreading)
	LogicalCores  int32 `protobuf:"varint,10,opt,name=logical_cores,json=logicalCores,proto3" json:"logical_cores,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CPUPackageNode) Reset() {
	*x = CPUPackageNode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CPUPackageNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CPUPackageNode) ProtoMessage() {}

func (x *CPUPackageNode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CPUPackageNode.ProtoReflect.Descriptor instead.
func (*CPUPackageNode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{1}
}

func (x *CPUPackageNode) GetSocketId() int32 {
	if x != nil {
		return x.SocketId
	}
	return 0
}

func (x *CPUPackageNode) GetVendorId() string {
	if x != nil {
		return x.VendorId
	}
	return ""
}

func (x *CPUPackageNode) GetModelName() string {
	if x != nil {
		return x.ModelName
	}
	return ""
}

func (x *CPUPackageNode) GetCpuFamily() int32 {
	if x != nil {
		return x.CpuFamily
	}
	return 0
}

func (x *CPUPackageNode) GetModel() int32 {
	if x != nil {
		return x.Model
	}
	return 0
}

func (x *CPUPackageNode) GetStepping() int32 {
	if x != nil {
		return x.Stepping
	}
	return 0
}

func (x *CPUPackageNode) GetMicrocode() string {
	if x != nil {
		return x.Microcode
	}
	return ""
}

func (x *CPUPackageNode) GetCacheSize() string {
	if x != nil {
		return x.CacheSize
	}
	return ""
}

func (x *CPUPackageNode) GetPhysicalCores() int32 {
	if x != nil {
		return x.PhysicalCores
	}
	return 0
}

func (x *CPUPackageNode) GetLogicalCores() int32 {
	if x != nil {
		return x.LogicalCores
	}
	return 0
}

// CPUCoreNode represents an individual CPU core
type CPUCoreNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Processor ID (logical CPU number)
	ProcessorId int32 `protobuf:"varint,1,opt,name=processor_id,json=processorId,proto3" json:"processor_id,omitempty"`
	// Physical core ID
	CoreId int32 `protobuf:"varint,2,opt,name=core_id,json=coreId,proto3" json:"core_id,omitempty"`
	// Physical package ID this core belongs to
	PhysicalId int32 `protobuf:"varint,3,opt,name=physical_id,json=physicalId,proto3" json:"physical_id,omitempty"`
	// Current frequency in MHz
	FrequencyMhz float64 `protobuf:"fixed64,4,opt,name=frequency_mhz,json=frequencyMhz,proto3" json:"frequency_mhz,omitempty"`
	// Number of sibling threads
	Siblings      int32 `protobuf:"varint,5,opt,name=siblings,proto3" json:"siblings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CPUCoreNode) Reset() {
	*x = CPUCoreNode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CPUCoreNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CPUCoreNode) ProtoMessage() {}

func (x *CPUCoreNode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CPUCoreNode.ProtoReflect.Descriptor instead.
func (*CPUCoreNode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{2}
}

func (x *CPUCoreNode) GetProcessorId() int32 {
	if x != nil {
		return x.ProcessorId
	}
	return 0
}

func (x *CPUCoreNode) GetCoreId() int32 {
	if x != nil {
		return x.CoreId
	}
	return 0
}

func (x *CPUCoreNode) GetPhysicalId() int32 {
	if x != nil {
		return x.PhysicalId
	}
	return 0
}

func (x *CPUCoreNode) GetFrequencyMhz() float64 {
	if x != nil {
		return x.FrequencyMhz
	}
	return 0
}

func (x *CPUCoreNode) GetSiblings() int32 {
	if x != nil {
		return x.Siblings
	}
	return 0
}

// NUMANode represents a NUMA memory node
type NUMANode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// NUMA node ID
	NodeId int32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Total memory in bytes for this NUMA node
	TotalBytes uint64 `protobuf:"varint,2,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// CPUs assigned to this NUMA node
	Cpus []int32 `protobuf:"varint,3,rep,packed,name=cpus,proto3" json:"cpus,omitempty"`
	// Distance to other NUMA nodes
	Distances     []int32 `protobuf:"varint,4,rep,packed,name=distances,proto3" json:"distances,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NUMANode) Reset() {
	*x = NUMANode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NUMANode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NUMANode) ProtoMessage() {}

func (x *NUMANode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NUMANode.ProtoReflect.Descriptor instead.
func (*NUMANode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{3}
}

func (x *NUMANode) GetNodeId() int32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *NUMANode) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *NUMANode) GetCpus() []int32 {
	if x != nil {
		return x.Cpus
	}
	return nil
}

func (x *NUMANode) GetDistances() []int32 {
	if x != nil {
		return x.Distances
	}
	return nil
}

// MemoryModuleNode represents system memory configuration
type MemoryModuleNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Total system memory in bytes
	TotalBytes uint64 `protobuf:"varint,1,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// Whether NUMA is enabled
	NumaEnabled bool `protobuf:"varint,2,opt,name=numa_enabled,json=numaEnabled,proto3" json:"numa_enabled,omitempty"`
	// Whether NUMA balancing is available
	NumaBalancingAvailable bool `protobuf:"varint,3,opt,name=numa_balancing_available,json=numaBalancingAvailable,proto3" json:"numa_balancing_available,omitempty"`
	// Number of NUMA nodes
	NumaNodeCount int32 `protobuf:"varint,4,opt,name=numa_node_count,json=numaNodeCount,proto3" json:"numa_node_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MemoryModuleNode) Reset() {
	*x = MemoryModuleNode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MemoryModuleNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MemoryModuleNode) ProtoMessage() {}

func (x *MemoryModuleNode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MemoryModuleNode.ProtoReflect.Descriptor instead.
func (*MemoryModuleNode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{4}
}

func (x *MemoryModuleNode) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *MemoryModuleNode) GetNumaEnabled() bool {
	if x != nil {
		return x.NumaEnabled
	}
	return false
}

func (x *MemoryModuleNode) GetNumaBalancingAvailable() bool {
	if x != nil {
		return x.NumaBalancingAvailable
	}
	return false
}

func (x *MemoryModuleNode) GetNumaNodeCount() int32 {
	if x != nil {
		return x.NumaNodeCount
	}
	return 0
}

// DiskDeviceNode represents a physical storage device
type DiskDeviceNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Device name (e.g., sda, nvme0n1)
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Model name
	Model string `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
	// Vendor/manufacturer
	Vendor string `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// Size in bytes
	SizeBytes uint64 `protobuf:"varint,4,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Whether it's a rotational disk (HDD) or not (SSD)
	Rotational bool `protobuf:"varint,5,opt,name=rotational,proto3" json:"rotational,omitempty"`
	// Logical block size
	BlockSize uint32 `protobuf:"varint,6,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	// Physical block size
	PhysicalBlockSize uint32 `protobuf:"varint,7,opt,name=physical_block_size,json=physicalBlockSize,proto3" json:"physical_block_size,omitempty"`
	// I/O scheduler
	Scheduler string `protobuf:"bytes,8,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// Queue depth
	QueueDepth    uint32 `protobuf:"varint,9,opt,name=queue_depth,json=queueDepth,proto3" json:"queue_depth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiskDeviceNode) Reset() {
	*x = DiskDeviceNode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiskDeviceNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiskDeviceNode) ProtoMessage() {}

func (x *DiskDeviceNode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiskDeviceNode.ProtoReflect.Descriptor instead.
func (*DiskDeviceNode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{5}
}

func (x *DiskDeviceNode) GetDevice() string {
	if x != nil {
		return x.Device
	}
	return ""
}

func (x *DiskDeviceNode) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *DiskDeviceNode) GetVendor() string {
	if x != nil {
		return x.Vendor
	}
	return ""
}

func (x *DiskDeviceNode) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DiskDeviceNode) GetRotational() bool {
	if x != nil {
		return x.Rotational
	}
	return false
}

func (x *DiskDeviceNode) GetBlockSize() uint32 {
	if x != nil {
		return x.BlockSize
	}
	return 0
}

func (x *DiskDeviceNode) GetPhysicalBlockSize() uint32 {
	if x != nil {
		return x.PhysicalBlockSize
	}
	return 0
}

func (x *DiskDeviceNode) GetScheduler() string {
	if x != nil {
		return x.Scheduler
	}
	return ""
}

func (x *DiskDeviceNode) GetQueueDepth() uint32 {
	if x != nil {
		return x.QueueDepth
	}
	return 0
}

// DiskPartitionNode represents a disk partition
type DiskPartitionNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Partition name (e.g., sda1, nvme0n1p1)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Parent device name
	ParentDevice string `protobuf:"bytes,2,opt,name=parent_device,json=parentDevice,proto3" json:"parent_device,omitempty"`
	// Size in bytes
	SizeBytes uint64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Starting sector
	StartSector   uint64 `protobuf:"varint,4,opt,name=start_sector,json=startSector,proto3" json:"start_sector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiskPartitionNode) Reset() {
	*x = DiskPartitionNode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiskPartitionNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiskPartitionNode) ProtoMessage() {}

func (x *DiskPartitionNode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiskPartitionNode.ProtoReflect.Descriptor instead.
func (*DiskPartitionNode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{6}
}

func (x *DiskPartitionNode) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DiskPartitionNode) GetParentDevice() string {
	if x != nil {
		return x.ParentDevice
	}
	return ""
}

func (x *DiskPartitionNode) GetSizeBytes() uint64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *DiskPartitionNode) GetStartSector() uint64 {
	if x != nil {
		return x.StartSector
	}
	return 0
}

// NetworkInterfaceNode represents a network interface (both physical NICs and virtual interfaces)
// For physical network cards, the interface field will contain the physical device name
// Virtual interfaces (VLANs, bridges, etc.) can be related to physical NICs via relationships
type NetworkInterfaceNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Interface name (e.g., eth0, wlan0)
	Interface string `protobuf:"bytes,1,opt,name=interface,proto3" json:"interface,omitempty"`
	// MAC address
	MacAddress string `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// Link speed in Mbps
	Speed uint64 `protobuf:"varint,3,opt,name=speed,proto3" json:"speed,omitempty"`
	// Duplex mode
	Duplex DuplexMode `protobuf:"varint,4,opt,name=duplex,proto3,enum=antimetal.hardware.v1.DuplexMode" json:"duplex,omitempty"`
	// Maximum transmission unit
	Mtu uint32 `protobuf:"varint,5,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Driver name
	Driver string `protobuf:"bytes,6,opt,name=driver,proto3" json:"driver,omitempty"`
	// Interface type
	Type InterfaceType `protobuf:"varint,7,opt,name=type,proto3,enum=antimetal.hardware.v1.InterfaceType" json:"type,omitempty"`
	// IPv4 addresses assigned to this interface
	Ipv4Addresses []string `protobuf:"bytes,10,rep,name=ipv4_addresses,json=ipv4Addresses,proto3" json:"ipv4_addresses,omitempty"`
	// IPv6 addresses assigned to this interface
	Ipv6Addresses []string `protobuf:"bytes,11,rep,name=ipv6_addresses,json=ipv6Addresses,proto3" json:"ipv6_addresses,omitempty"`
	// Operational state
	OperState OperationalState `protobuf:"varint,8,opt,name=oper_state,json=operState,proto3,enum=antimetal.hardware.v1.OperationalState" json:"oper_state,omitempty"`
	// Carrier status
	Carrier       bool `protobuf:"varint,9,opt,name=carrier,proto3" json:"carrier,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkInterfaceNode) Reset() {
	*x = NetworkInterfaceNode{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInterfaceNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInterfaceNode) ProtoMessage() {}

func (x *NetworkInterfaceNode) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInterfaceNode.ProtoReflect.Descriptor instead.
func (*NetworkInterfaceNode) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{7}
}

func (x *NetworkInterfaceNode) GetInterface() string {
	if x != nil {
		return x.Interface
	}
	return ""
}

func (x *NetworkInterfaceNode) GetMacAddress() string {
	if x != nil {
		return x.MacAddress
	}
	return ""
}

func (x *NetworkInterfaceNode) GetSpeed() uint64 {
	if x != nil {
		return x.Speed
	}
	return 0
}

func (x *NetworkInterfaceNode) GetDuplex() DuplexMode {
	if x != nil {
		return x.Duplex
	}
	return DuplexMode_DUPLEX_MODE_UNKNOWN
}

func (x *NetworkInterfaceNode) GetMtu() uint32 {
	if x != nil {
		return x.Mtu
	}
	return 0
}

func (x *NetworkInterfaceNode) GetDriver() string {
	if x != nil {
		return x.Driver
	}
	return ""
}

func (x *NetworkInterfaceNode) GetType() InterfaceType {
	if x != nil {
		return x.Type
	}
	return InterfaceType_INTERFACE_TYPE_UNKNOWN
}

func (x *NetworkInterfaceNode) GetIpv4Addresses() []string {
	if x != nil {
		return x.Ipv4Addresses
	}
	return nil
}

func (x *NetworkInterfaceNode) GetIpv6Addresses() []string {
	if x != nil {
		return x.Ipv6Addresses
	}
	return nil
}

func (x *NetworkInterfaceNode) GetOperState() OperationalState {
	if x != nil {
		return x.OperState
	}
	return OperationalState_OPERATIONAL_STATE_UNKNOWN
}

func (x *NetworkInterfaceNode) GetCarrier() bool {
	if x != nil {
		return x.Carrier
	}
	return false
}

// Contains represents hierarchical containment relationship
type Contains struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of containment
	Type          ContainmentType `protobuf:"varint,1,opt,name=type,proto3,enum=antimetal.hardware.v1.ContainmentType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Contains) Reset() {
	*x = Contains{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Contains) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Contains) ProtoMessage() {}

func (x *Contains) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Contains.ProtoReflect.Descriptor instead.
func (*Contains) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{8}
}

func (x *Contains) GetType() ContainmentType {
	if x != nil {
		return x.Type
	}
	return ContainmentType_CONTAINMENT_TYPE_UNKNOWN
}

// NUMAAffinity represents NUMA node affinity
type NUMAAffinity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// NUMA node ID
	NodeId int32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Distance metric (for NUMA distance relationships)
	Distance      int32 `protobuf:"varint,2,opt,name=distance,proto3" json:"distance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NUMAAffinity) Reset() {
	*x = NUMAAffinity{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NUMAAffinity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NUMAAffinity) ProtoMessage() {}

func (x *NUMAAffinity) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NUMAAffinity.ProtoReflect.Descriptor instead.
func (*NUMAAffinity) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{9}
}

func (x *NUMAAffinity) GetNodeId() int32 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *NUMAAffinity) GetDistance() int32 {
	if x != nil {
		return x.Distance
	}
	return 0
}

// SocketSharing represents CPU cores sharing a physical socket
type SocketSharing struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Physical package ID
	PhysicalId int32 `protobuf:"varint,1,opt,name=physical_id,json=physicalId,proto3" json:"physical_id,omitempty"`
	// Socket ID
	SocketId      int32 `protobuf:"varint,2,opt,name=socket_id,json=socketId,proto3" json:"socket_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SocketSharing) Reset() {
	*x = SocketSharing{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SocketSharing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SocketSharing) ProtoMessage() {}

func (x *SocketSharing) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SocketSharing.ProtoReflect.Descriptor instead.
func (*SocketSharing) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{10}
}

func (x *SocketSharing) GetPhysicalId() int32 {
	if x != nil {
		return x.PhysicalId
	}
	return 0
}

func (x *SocketSharing) GetSocketId() int32 {
	if x != nil {
		return x.SocketId
	}
	return 0
}

// BusConnection represents hardware bus connections
type BusConnection struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bus type
	BusType BusType `protobuf:"varint,1,opt,name=bus_type,json=busType,proto3,enum=antimetal.hardware.v1.BusType" json:"bus_type,omitempty"`
	// Optional bus address
	BusAddress    string `protobuf:"bytes,2,opt,name=bus_address,json=busAddress,proto3" json:"bus_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BusConnection) Reset() {
	*x = BusConnection{}
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BusConnection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BusConnection) ProtoMessage() {}

func (x *BusConnection) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_hardware_v1_hardware_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BusConnection.ProtoReflect.Descriptor instead.
func (*BusConnection) Descriptor() ([]byte, []int) {
	return file_antimetal_hardware_v1_hardware_proto_rawDescGZIP(), []int{11}
}

func (x *BusConnection) GetBusType() BusType {
	if x != nil {
		return x.BusType
	}
	return BusType_BUS_TYPE_UNKNOWN
}

func (x *BusConnection) GetBusAddress() string {
	if x != nil {
		return x.BusAddress
	}
	return ""
}

var File_antimetal_hardware_v1_hardware_proto protoreflect.FileDescriptor

const file_antimetal_hardware_v1_hardware_proto_rawDesc = "" +
	"\n" +
	"$antimetal/hardware/v1/hardware.proto\x12\x15antimetal.hardware.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xea\x01\n" +
	"\n" +
	"SystemNode\x12\x1a\n" +
	"\bhostname\x18\x01 \x01(\tR\bhostname\x12G\n" +
	"\farchitecture\x18\x02 \x01(\x0e2#.antimetal.hardware.v1.ArchitectureR\farchitecture\x127\n" +
	"\tboot_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\bbootTime\x12%\n" +
	"\x0ekernel_version\x18\x04 \x01(\tR\rkernelVersion\x12\x17\n" +
	"\aos_info\x18\x05 \x01(\tR\x06osInfo\"\xc3\x02\n" +
	"\x0eCPUPackageNode\x12\x1b\n" +
	"\tsocket_id\x18\x01 \x01(\x05R\bsocketId\x12\x1b\n" +
	"\tvendor_id\x18\x02 \x01(\tR\bvendorId\x12\x1d\n" +
	"\n" +
	"model_name\x18\x03 \x01(\tR\tmodelName\x12\x1d\n" +
	"\n" +
	"cpu_family\x18\x04 \x01(\x05R\tcpuFamily\x12\x14\n" +
	"\x05model\x18\x05 \x01(\x05R\x05model\x12\x1a\n" +
	"\bstepping\x18\x06 \x01(\x05R\bstepping\x12\x1c\n" +
	"\tmicrocode\x18\a \x01(\tR\tmicrocode\x12\x1d\n" +
	"\n" +
	"cache_size\x18\b \x01(\tR\tcacheSize\x12%\n" +
	"\x0ephysical_cores\x18\t \x01(\x05R\rphysicalCores\x12#\n" +
	"\rlogical_cores\x18\n" +
	" \x01(\x05R\flogicalCores\"\xab\x01\n" +
	"\vCPUCoreNode\x12!\n" +
	"\fprocessor_id\x18\x01 \x01(\x05R\vprocessorId\x12\x17\n" +
	"\acore_id\x18\x02 \x01(\x05R\x06coreId\x12\x1f\n" +
	"\vphysical_id\x18\x03 \x01(\x05R\n" +
	"physicalId\x12#\n" +
	"\rfrequency_mhz\x18\x04 \x01(\x01R\ffrequencyMhz\x12\x1a\n" +
	"\bsiblings\x18\x05 \x01(\x05R\bsiblings\"v\n" +
	"\bNUMANode\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\x05R\x06nodeId\x12\x1f\n" +
	"\vtotal_bytes\x18\x02 \x01(\x04R\n" +
	"totalBytes\x12\x12\n" +
	"\x04cpus\x18\x03 \x03(\x05R\x04cpus\x12\x1c\n" +
	"\tdistances\x18\x04 \x03(\x05R\tdistances\"\xb8\x01\n" +
	"\x10MemoryModuleNode\x12\x1f\n" +
	"\vtotal_bytes\x18\x01 \x01(\x04R\n" +
	"totalBytes\x12!\n" +
	"\fnuma_enabled\x18\x02 \x01(\bR\vnumaEnabled\x128\n" +
	"\x18numa_balancing_available\x18\x03 \x01(\bR\x16numaBalancingAvailable\x12&\n" +
	"\x0fnuma_node_count\x18\x04 \x01(\x05R\rnumaNodeCount\"\xa3\x02\n" +
	"\x0eDiskDeviceNode\x12\x16\n" +
	"\x06device\x18\x01 \x01(\tR\x06device\x12\x14\n" +
	"\x05model\x18\x02 \x01(\tR\x05model\x12\x16\n" +
	"\x06vendor\x18\x03 \x01(\tR\x06vendor\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x04 \x01(\x04R\tsizeBytes\x12\x1e\n" +
	"\n" +
	"rotational\x18\x05 \x01(\bR\n" +
	"rotational\x12\x1d\n" +
	"\n" +
	"block_size\x18\x06 \x01(\rR\tblockSize\x12.\n" +
	"\x13physical_block_size\x18\a \x01(\rR\x11physicalBlockSize\x12\x1c\n" +
	"\tscheduler\x18\b \x01(\tR\tscheduler\x12\x1f\n" +
	"\vqueue_depth\x18\t \x01(\rR\n" +
	"queueDepth\"\x8e\x01\n" +
	"\x11DiskPartitionNode\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12#\n" +
	"\rparent_device\x18\x02 \x01(\tR\fparentDevice\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x03 \x01(\x04R\tsizeBytes\x12!\n" +
	"\fstart_sector\x18\x04 \x01(\x04R\vstartSector\"\xba\x03\n" +
	"\x14NetworkInterfaceNode\x12\x1c\n" +
	"\tinterface\x18\x01 \x01(\tR\tinterface\x12\x1f\n" +
	"\vmac_address\x18\x02 \x01(\tR\n" +
	"macAddress\x12\x14\n" +
	"\x05speed\x18\x03 \x01(\x04R\x05speed\x129\n" +
	"\x06duplex\x18\x04 \x01(\x0e2!.antimetal.hardware.v1.DuplexModeR\x06duplex\x12\x10\n" +
	"\x03mtu\x18\x05 \x01(\rR\x03mtu\x12\x16\n" +
	"\x06driver\x18\x06 \x01(\tR\x06driver\x128\n" +
	"\x04type\x18\a \x01(\x0e2$.antimetal.hardware.v1.InterfaceTypeR\x04type\x12%\n" +
	"\x0eipv4_addresses\x18\n" +
	" \x03(\tR\ripv4Addresses\x12%\n" +
	"\x0eipv6_addresses\x18\v \x03(\tR\ripv6Addresses\x12F\n" +
	"\n" +
	"oper_state\x18\b \x01(\x0e2'.antimetal.hardware.v1.OperationalStateR\toperState\x12\x18\n" +
	"\acarrier\x18\t \x01(\bR\acarrier\"F\n" +
	"\bContains\x12:\n" +
	"\x04type\x18\x01 \x01(\x0e2&.antimetal.hardware.v1.ContainmentTypeR\x04type\"C\n" +
	"\fNUMAAffinity\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\x05R\x06nodeId\x12\x1a\n" +
	"\bdistance\x18\x02 \x01(\x05R\bdistance\"M\n" +
	"\rSocketSharing\x12\x1f\n" +
	"\vphysical_id\x18\x01 \x01(\x05R\n" +
	"physicalId\x12\x1b\n" +
	"\tsocket_id\x18\x02 \x01(\x05R\bsocketId\"k\n" +
	"\rBusConnection\x129\n" +
	"\bbus_type\x18\x01 \x01(\x0e2\x1e.antimetal.hardware.v1.BusTypeR\abusType\x12\x1f\n" +
	"\vbus_address\x18\x02 \x01(\tR\n" +
	"busAddress*\x93\x03\n" +
	"\fArchitecture\x12\x18\n" +
	"\x14ARCHITECTURE_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10ARCHITECTURE_X86\x10\x01\x12\x17\n" +
	"\x13ARCHITECTURE_X86_64\x10\x02\x12\x14\n" +
	"\x10ARCHITECTURE_ARM\x10\x03\x12\x16\n" +
	"\x12ARCHITECTURE_ARM64\x10\x04\x12\x14\n" +
	"\x10ARCHITECTURE_PPC\x10\x05\x12\x16\n" +
	"\x12ARCHITECTURE_PPC64\x10\x06\x12\x18\n" +
	"\x14ARCHITECTURE_PPC64LE\x10\a\x12\x15\n" +
	"\x11ARCHITECTURE_S390\x10\b\x12\x16\n" +
	"\x12ARCHITECTURE_S390X\x10\t\x12\x15\n" +
	"\x11ARCHITECTURE_MIPS\x10\n" +
	"\x12\x17\n" +
	"\x13ARCHITECTURE_MIPS64\x10\v\x12\x19\n" +
	"\x15ARCHITECTURE_MIPS64LE\x10\f\x12\x18\n" +
	"\x14ARCHITECTURE_RISCV64\x10\r\x12\x16\n" +
	"\x12ARCHITECTURE_SPARC\x10\x0e\x12\x18\n" +
	"\x14ARCHITECTURE_SPARC64\x10\x0f*\xba\x02\n" +
	"\rInterfaceType\x12\x1a\n" +
	"\x16INTERFACE_TYPE_UNKNOWN\x10\x00\x12\x1b\n" +
	"\x17INTERFACE_TYPE_ETHERNET\x10\x01\x12\x1b\n" +
	"\x17INTERFACE_TYPE_WIRELESS\x10\x02\x12\x1b\n" +
	"\x17INTERFACE_TYPE_LOOPBACK\x10\x03\x12\x1a\n" +
	"\x16INTERFACE_TYPE_VIRTUAL\x10\x04\x12\x19\n" +
	"\x15INTERFACE_TYPE_BRIDGE\x10\x05\x12\x17\n" +
	"\x13INTERFACE_TYPE_VLAN\x10\x06\x12\x16\n" +
	"\x12INTERFACE_TYPE_TUN\x10\a\x12\x16\n" +
	"\x12INTERFACE_TYPE_TAP\x10\b\x12\x17\n" +
	"\x13INTERFACE_TYPE_BOND\x10\t\x12\x1d\n" +
	"\x19INTERFACE_TYPE_INFINIBAND\x10\n" +
	"*\xc8\x01\n" +
	"\aBusType\x12\x14\n" +
	"\x10BUS_TYPE_UNKNOWN\x10\x00\x12\x10\n" +
	"\fBUS_TYPE_PCI\x10\x01\x12\x11\n" +
	"\rBUS_TYPE_PCIE\x10\x02\x12\x10\n" +
	"\fBUS_TYPE_USB\x10\x03\x12\x11\n" +
	"\rBUS_TYPE_SATA\x10\x04\x12\x11\n" +
	"\rBUS_TYPE_NVME\x10\x05\x12\x10\n" +
	"\fBUS_TYPE_SAS\x10\x06\x12\x10\n" +
	"\fBUS_TYPE_IDE\x10\a\x12\x11\n" +
	"\rBUS_TYPE_SCSI\x10\b\x12\x13\n" +
	"\x0fBUS_TYPE_VIRTIO\x10\t*Q\n" +
	"\n" +
	"DuplexMode\x12\x17\n" +
	"\x13DUPLEX_MODE_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10DUPLEX_MODE_HALF\x10\x01\x12\x14\n" +
	"\x10DUPLEX_MODE_FULL\x10\x02*\xf0\x01\n" +
	"\x10OperationalState\x12\x1d\n" +
	"\x19OPERATIONAL_STATE_UNKNOWN\x10\x00\x12\x18\n" +
	"\x14OPERATIONAL_STATE_UP\x10\x01\x12\x1a\n" +
	"\x16OPERATIONAL_STATE_DOWN\x10\x02\x12\x1d\n" +
	"\x19OPERATIONAL_STATE_TESTING\x10\x03\x12\x1d\n" +
	"\x19OPERATIONAL_STATE_DORMANT\x10\x04\x12!\n" +
	"\x1dOPERATIONAL_STATE_NOT_PRESENT\x10\x05\x12&\n" +
	"\"OPERATIONAL_STATE_LOWER_LAYER_DOWN\x10\x06*\x8c\x01\n" +
	"\x0fContainmentType\x12\x1c\n" +
	"\x18CONTAINMENT_TYPE_UNKNOWN\x10\x00\x12\x1d\n" +
	"\x19CONTAINMENT_TYPE_PHYSICAL\x10\x01\x12\x1c\n" +
	"\x18CONTAINMENT_TYPE_LOGICAL\x10\x02\x12\x1e\n" +
	"\x1aCONTAINMENT_TYPE_PARTITION\x10\x03B\xe5\x01\n" +
	"\x19com.antimetal.hardware.v1B\rHardwareProtoP\x01ZCgithub.com/antimetal/agent/pkg/api/antimetal/hardware/v1;hardwarev1\xa2\x02\x03AHX\xaa\x02\x15Antimetal.Hardware.V1\xca\x02\x15Antimetal\\Hardware\\V1\xe2\x02!Antimetal\\Hardware\\V1\\GPBMetadata\xea\x02\x17Antimetal::Hardware::V1b\x06proto3"

var (
	file_antimetal_hardware_v1_hardware_proto_rawDescOnce sync.Once
	file_antimetal_hardware_v1_hardware_proto_rawDescData []byte
)

func file_antimetal_hardware_v1_hardware_proto_rawDescGZIP() []byte {
	file_antimetal_hardware_v1_hardware_proto_rawDescOnce.Do(func() {
		file_antimetal_hardware_v1_hardware_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_antimetal_hardware_v1_hardware_proto_rawDesc), len(file_antimetal_hardware_v1_hardware_proto_rawDesc)))
	})
	return file_antimetal_hardware_v1_hardware_proto_rawDescData
}

var file_antimetal_hardware_v1_hardware_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_antimetal_hardware_v1_hardware_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_antimetal_hardware_v1_hardware_proto_goTypes = []any{
	(Architecture)(0),             // 0: antimetal.hardware.v1.Architecture
	(InterfaceType)(0),            // 1: antimetal.hardware.v1.InterfaceType
	(BusType)(0),                  // 2: antimetal.hardware.v1.BusType
	(DuplexMode)(0),               // 3: antimetal.hardware.v1.DuplexMode
	(OperationalState)(0),         // 4: antimetal.hardware.v1.OperationalState
	(ContainmentType)(0),          // 5: antimetal.hardware.v1.ContainmentType
	(*SystemNode)(nil),            // 6: antimetal.hardware.v1.SystemNode
	(*CPUPackageNode)(nil),        // 7: antimetal.hardware.v1.CPUPackageNode
	(*CPUCoreNode)(nil),           // 8: antimetal.hardware.v1.CPUCoreNode
	(*NUMANode)(nil),              // 9: antimetal.hardware.v1.NUMANode
	(*MemoryModuleNode)(nil),      // 10: antimetal.hardware.v1.MemoryModuleNode
	(*DiskDeviceNode)(nil),        // 11: antimetal.hardware.v1.DiskDeviceNode
	(*DiskPartitionNode)(nil),     // 12: antimetal.hardware.v1.DiskPartitionNode
	(*NetworkInterfaceNode)(nil),  // 13: antimetal.hardware.v1.NetworkInterfaceNode
	(*Contains)(nil),              // 14: antimetal.hardware.v1.Contains
	(*NUMAAffinity)(nil),          // 15: antimetal.hardware.v1.NUMAAffinity
	(*SocketSharing)(nil),         // 16: antimetal.hardware.v1.SocketSharing
	(*BusConnection)(nil),         // 17: antimetal.hardware.v1.BusConnection
	(*timestamppb.Timestamp)(nil), // 18: google.protobuf.Timestamp
}
var file_antimetal_hardware_v1_hardware_proto_depIdxs = []int32{
	0,  // 0: antimetal.hardware.v1.SystemNode.architecture:type_name -> antimetal.hardware.v1.Architecture
	18, // 1: antimetal.hardware.v1.SystemNode.boot_time:type_name -> google.protobuf.Timestamp
	3,  // 2: antimetal.hardware.v1.NetworkInterfaceNode.duplex:type_name -> antimetal.hardware.v1.DuplexMode
	1,  // 3: antimetal.hardware.v1.NetworkInterfaceNode.type:type_name -> antimetal.hardware.v1.InterfaceType
	4,  // 4: antimetal.hardware.v1.NetworkInterfaceNode.oper_state:type_name -> antimetal.hardware.v1.OperationalState
	5,  // 5: antimetal.hardware.v1.Contains.type:type_name -> antimetal.hardware.v1.ContainmentType
	2,  // 6: antimetal.hardware.v1.BusConnection.bus_type:type_name -> antimetal.hardware.v1.BusType
	7,  // [7:7] is the sub-list for method output_type
	7,  // [7:7] is the sub-list for method input_type
	7,  // [7:7] is the sub-list for extension type_name
	7,  // [7:7] is the sub-list for extension extendee
	0,  // [0:7] is the sub-list for field type_name
}

func init() { file_antimetal_hardware_v1_hardware_proto_init() }
func file_antimetal_hardware_v1_hardware_proto_init() {
	if File_antimetal_hardware_v1_hardware_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_antimetal_hardware_v1_hardware_proto_rawDesc), len(file_antimetal_hardware_v1_hardware_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_antimetal_hardware_v1_hardware_proto_goTypes,
		DependencyIndexes: file_antimetal_hardware_v1_hardware_proto_depIdxs,
		EnumInfos:         file_antimetal_hardware_v1_hardware_proto_enumTypes,
		MessageInfos:      file_antimetal_hardware_v1_hardware_proto_msgTypes,
	}.Build()
	File_antimetal_hardware_v1_hardware_proto = out.File
	file_antimetal_hardware_v1_hardware_proto_goTypes = nil
	file_antimetal_hardware_v1_hardware_proto_depIdxs = nil
}
