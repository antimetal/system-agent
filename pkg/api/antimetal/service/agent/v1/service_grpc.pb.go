// Antimetal API definitions
// Copyright Antimetal, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: antimetal/service/agent/v1/service.proto

package agentv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AgentManagementService_WatchConfig_FullMethodName = "/antimetal.service.agent.v1.AgentManagementService/WatchConfig"
)

// AgentManagementServiceClient is the client API for AgentManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The server will then send a WatchConfigResponse containing any configuration
// objects that have changed since the last config versions that the Agent indicated
// it has seen as well as any new configuration objects for the Agent. Configuration
// objects are specific config message types (e.g., HostStatsCollectionConfig)
// wrapped directly in antimetal.types.v1.Object. The server may send additional responses
// at any time for new or updated configs.
//
// Whenever the Agent receives a new response, it will send another WatchConfigRequest
// of either ACK or NACK type indicating whether or not the individual config objects
// in the response were valid in isolation (see ACK/NACK and config versions for details).
//
// All server responses will contain a sequence number. Subsequent requests from the
// Agent must set the response_seq_num field to the most recent sequence number
// received from the server on that stream. This allows the management server to
// determine which response a given request is associated with, which avoids various
// race conditions. Note that the sequence number does not survive stream restarts.
//
// Only the first request on a stream is guaranteed to carry the Agent instance
// identifier. Subsequent requests on the same stream may carry an empty Agent
// instance identifier. The Agent instance identifier should always be identical
// if present more than once on the stream.
//
// # ACK/NACK and Config Version
//
// Each configuration object is wrapped in an antimetal.types.v1.Object and
// has independent versioning. Config object versions are managed via the `version`
// field in `antimetal.types.v1.Object`. The version for a particular config
// is changed when the management server sends an updated config of the same
// object name and type. Configuration objects are specific message types
// (e.g., HostStatsCollectionConfig).
//
// Note that the version for a config is not a property of an individual stream
// but rather a property of the configs themselves. If the stream becomes broken
// and the Agent creates a new stream, the Agent’s initial request on the new stream
// should indicate the most recent version seen by the Agent on the previous stream.
// The management server may decide to optimize by not resending configs that the Agent
// had already seen on the previous stream but only if the Agent registers itself
// as the same instance with the same instance id as before. If the Agent starts
// a new stream with a different instance id, then the management server can assume
// that it is a new Agent process with separate configs.
//
// ## ACK
//
// An ACK (acknowledgment) indicates that all configuration objects in the server
// response were valid and successfully applied by the Agent.
//
// The Agent sends back the sequence number of the successfully validated response
// and SHOULD store the versions of all accepted objects for future reference.
// Subsequent INITIAL requests should include these object versions.
//
// Agent                                    Management Server
//
//	|                                           |
//	|<------- config update ------------------- |
//	|         (seq: "n", version: "2")          |
//	|                                           |
//	| [Agent validates config syntax: OK]       |
//	| [Agent applies config to runtime: OK]     |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         (response_seq_num: "n")           |
//
// ## NACK
//
// A NACK (negative acknowledgment) indicates that at least one config object in
// the response was invalid and was not applied. The Agent sends back the sequence
// number of the rejected response and MUST include detailed error information in
// `error_detail`. The management server can use the error details to send corrected
// configuration.
//
// For configuration-specific errors, agents should include ConfigError details
// in the error_detail to provide structured information about which configuration
// object failed and why.
//
// Agent                                    Management Server
//
//	|                                           |
//	|<------- config update ------------------- |
//	|         (seq: "n", version: "v2")         |
//	|                                           |
//	| [Agent validates config: INVALID]         |
//	|                                           |
//	|-------- NACK request -------------------->|
//	|         (response_seq_num: "n")           |
//	|         (error: "missing field X")        |
//	|                                           |
//	|<------- corrected config -----------------|
//	|         (seq: "n+1", version: "v3")       |
//	|                                           |
//	| [Agent validates: OK, applies: OK]        |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         (response_seq_num: "n+1")         |
//
// # Collector Capability Negotiation
//
// Agents MUST declare their supported data collector capabilities during stream
// initialization using the supported_collectors field in INITIAL requests. This
// enables the management server to send only relevant configurations and avoid
// capability mismatches that would result in NACK responses.
//
// ## Mandatory Capability Declaration
//
// The supported_collectors field is a list of collector identifier strings.
// Agents MUST include all collectors they can support:
//
// ```
//
//	WatchConfigRequest {
//	  type: INITIAL
//	  instance: { id: "agent-123", ... }
//	  supported_collectors: [
//	    "sys.cpu",
//	    "cpu.info",
//	    "sys.mem",
//	    "mem.info",
//	    "sys.net"
//	  ]
//	  initial_configs: [...]
//	}
//
// ```
//
// ## Agent NACK for Unsupported Capabilities
//
// If the server sends a configuration requiring collectors not declared in
// supported_collectors, the agent SHOULD respond with a NACK:
//
// Agent                                    Management Server
//
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         supported_collectors: [           |
//	|           "sys.cpu",                      | (CPU + MEM only)
//	|           "sys.mem"                       |
//	|         ]                                 |
//	|                                           |
//	|<------- network config ------------------|
//	|         (requires "sys.net")              |
//	|         seq_num: "1"                      |
//	|                                           |
//	|-------- NACK request -------------------->|
//	|         response_seq_num: "1"             |
//	|         error_detail: {                   |
//	|           code: FAILED_PRECONDITION       |
//	|           message: "Unsupported collector:|
//	|                     config requires       |
//	|                     sys.net"              |
//	|         }                                 |
//
// # Reconnection with Version Sync
//
// On reconnect the Agent may tell the management server the current configs it has
// to avoid resending them over the wire by sending the management server the config
// names and types in initial_configs. Because no state is assumed to be preserved
// from the previous stream, the reconnecting Agent must provide the server with all
// config names and types that it has.
//
// Note that the Agent sends its initial configs also in a antimetal.types.v1.Object
// but it only needs to supply the object name, type, and current version that it has.
// The object data field may be left empty.
//
// Agent                                    Management Server
//
//	|                                           |
//	| [Stream reconnection after failure]      |
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         (instance: same-id)               |
//	|         (last versions: "cfg-v4")         |
//	|                                           |
//	| [Server checks: cfg-v4 != current cfg-v6]|
//	|                                           |
//	|<------- incremental update --------------|
//	|         (seq: "1", version: "cfg-v6")     |
//	|         (only changed configs sent)       |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         (response_seq_num: "1")           |
//
// ```
//
// # Full Example
//
// This comprehensive example demonstrates the full protocol across multiple streams.
//
// ========== STREAM 1 (Agent Startup) ==========
// Agent                                    Management Server
//
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         type: INITIAL                     |
//	|         instance: {id: "agt-abc123"}      |
//	|         supported_collectors: [           | (CPU+MEM capabilities)
//	|           "sys.cpu",                      |
//	|           "sys.mem"                       |
//	|         ]                                 |
//	|         initial_configs: []               | (new agent)
//	|                                           |
//	|<------- first config -------------------|
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v1",                  |
//	|           data: <serialized HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "1"                      |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "1"             |
//	|                                           |
//	|<------- config update ------------------- |
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v2",                  |
//	|           data: <updated HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "2"                      |
//	|                                           |
//	|-------- NACK request -------------------->|
//	|         type: NACK                        |
//	|         response_seq_num: "2"             |
//	|         error_detail: {                   |
//	|           message: "invalid sampling rate"|
//	|         }                                 |
//	|                                           |
//	|<------- corrected config ---------------- |
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v3",                  |
//	|           data: <fixed HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "3"                      |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "3"             |
//	|                                           |
//	| [Agent persists: node-config@v3           |
//	|                                           |
//	|         *** NETWORK INTERRUPTION ***      |
//	|                                           |
//	|                                           |
//
// ========== STREAM 2 (Reconnection) ==========
//
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         type: INITIAL                     |
//	|         instance: {id: "agt-abc123"}      | (same agent instance)
//	|         supported_collectors: [           | (same capabilities)
//	|           "sys.cpu",                      |
//	|           "sys.mem"                       |
//	|         ]                                 |
//	|         initial_configs: [{               |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v3"                   | (last known version)
//	|         }]                                |
//	|                                           |
//	|<------- no-op response -------------------|
//	|         configs: []                       | (agent is up-to-date)
//	|         seq_num: "1"                      | ◀── seq number RESETS
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "1"             |
//	|                                           |
//	|         [Time passes...]                  |
//	|                                           |
//	|<------- new config update ----------------|
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v4",                  |
//	|           data: <updated HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "2"                      |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "2"             |
//	|                                           |
//	| [Agent persists: node-config@v4           |
type AgentManagementServiceClient interface {
	// WatchConfig establishes a bidirectional streaming connection for configuration
	// management between an Antimetal Agent and the management server.
	//
	// This RPC is long-lived and should remain open for the duration of the agent's
	// lifecycle.
	WatchConfig(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WatchConfigRequest, WatchConfigResponse], error)
}

type agentManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentManagementServiceClient(cc grpc.ClientConnInterface) AgentManagementServiceClient {
	return &agentManagementServiceClient{cc}
}

func (c *agentManagementServiceClient) WatchConfig(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WatchConfigRequest, WatchConfigResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentManagementService_ServiceDesc.Streams[0], AgentManagementService_WatchConfig_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchConfigRequest, WatchConfigResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentManagementService_WatchConfigClient = grpc.BidiStreamingClient[WatchConfigRequest, WatchConfigResponse]

// AgentManagementServiceServer is the server API for AgentManagementService service.
// All implementations must embed UnimplementedAgentManagementServiceServer
// for forward compatibility.
//
// The server will then send a WatchConfigResponse containing any configuration
// objects that have changed since the last config versions that the Agent indicated
// it has seen as well as any new configuration objects for the Agent. Configuration
// objects are specific config message types (e.g., HostStatsCollectionConfig)
// wrapped directly in antimetal.types.v1.Object. The server may send additional responses
// at any time for new or updated configs.
//
// Whenever the Agent receives a new response, it will send another WatchConfigRequest
// of either ACK or NACK type indicating whether or not the individual config objects
// in the response were valid in isolation (see ACK/NACK and config versions for details).
//
// All server responses will contain a sequence number. Subsequent requests from the
// Agent must set the response_seq_num field to the most recent sequence number
// received from the server on that stream. This allows the management server to
// determine which response a given request is associated with, which avoids various
// race conditions. Note that the sequence number does not survive stream restarts.
//
// Only the first request on a stream is guaranteed to carry the Agent instance
// identifier. Subsequent requests on the same stream may carry an empty Agent
// instance identifier. The Agent instance identifier should always be identical
// if present more than once on the stream.
//
// # ACK/NACK and Config Version
//
// Each configuration object is wrapped in an antimetal.types.v1.Object and
// has independent versioning. Config object versions are managed via the `version`
// field in `antimetal.types.v1.Object`. The version for a particular config
// is changed when the management server sends an updated config of the same
// object name and type. Configuration objects are specific message types
// (e.g., HostStatsCollectionConfig).
//
// Note that the version for a config is not a property of an individual stream
// but rather a property of the configs themselves. If the stream becomes broken
// and the Agent creates a new stream, the Agent’s initial request on the new stream
// should indicate the most recent version seen by the Agent on the previous stream.
// The management server may decide to optimize by not resending configs that the Agent
// had already seen on the previous stream but only if the Agent registers itself
// as the same instance with the same instance id as before. If the Agent starts
// a new stream with a different instance id, then the management server can assume
// that it is a new Agent process with separate configs.
//
// ## ACK
//
// An ACK (acknowledgment) indicates that all configuration objects in the server
// response were valid and successfully applied by the Agent.
//
// The Agent sends back the sequence number of the successfully validated response
// and SHOULD store the versions of all accepted objects for future reference.
// Subsequent INITIAL requests should include these object versions.
//
// Agent                                    Management Server
//
//	|                                           |
//	|<------- config update ------------------- |
//	|         (seq: "n", version: "2")          |
//	|                                           |
//	| [Agent validates config syntax: OK]       |
//	| [Agent applies config to runtime: OK]     |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         (response_seq_num: "n")           |
//
// ## NACK
//
// A NACK (negative acknowledgment) indicates that at least one config object in
// the response was invalid and was not applied. The Agent sends back the sequence
// number of the rejected response and MUST include detailed error information in
// `error_detail`. The management server can use the error details to send corrected
// configuration.
//
// For configuration-specific errors, agents should include ConfigError details
// in the error_detail to provide structured information about which configuration
// object failed and why.
//
// Agent                                    Management Server
//
//	|                                           |
//	|<------- config update ------------------- |
//	|         (seq: "n", version: "v2")         |
//	|                                           |
//	| [Agent validates config: INVALID]         |
//	|                                           |
//	|-------- NACK request -------------------->|
//	|         (response_seq_num: "n")           |
//	|         (error: "missing field X")        |
//	|                                           |
//	|<------- corrected config -----------------|
//	|         (seq: "n+1", version: "v3")       |
//	|                                           |
//	| [Agent validates: OK, applies: OK]        |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         (response_seq_num: "n+1")         |
//
// # Collector Capability Negotiation
//
// Agents MUST declare their supported data collector capabilities during stream
// initialization using the supported_collectors field in INITIAL requests. This
// enables the management server to send only relevant configurations and avoid
// capability mismatches that would result in NACK responses.
//
// ## Mandatory Capability Declaration
//
// The supported_collectors field is a list of collector identifier strings.
// Agents MUST include all collectors they can support:
//
// ```
//
//	WatchConfigRequest {
//	  type: INITIAL
//	  instance: { id: "agent-123", ... }
//	  supported_collectors: [
//	    "sys.cpu",
//	    "cpu.info",
//	    "sys.mem",
//	    "mem.info",
//	    "sys.net"
//	  ]
//	  initial_configs: [...]
//	}
//
// ```
//
// ## Agent NACK for Unsupported Capabilities
//
// If the server sends a configuration requiring collectors not declared in
// supported_collectors, the agent SHOULD respond with a NACK:
//
// Agent                                    Management Server
//
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         supported_collectors: [           |
//	|           "sys.cpu",                      | (CPU + MEM only)
//	|           "sys.mem"                       |
//	|         ]                                 |
//	|                                           |
//	|<------- network config ------------------|
//	|         (requires "sys.net")              |
//	|         seq_num: "1"                      |
//	|                                           |
//	|-------- NACK request -------------------->|
//	|         response_seq_num: "1"             |
//	|         error_detail: {                   |
//	|           code: FAILED_PRECONDITION       |
//	|           message: "Unsupported collector:|
//	|                     config requires       |
//	|                     sys.net"              |
//	|         }                                 |
//
// # Reconnection with Version Sync
//
// On reconnect the Agent may tell the management server the current configs it has
// to avoid resending them over the wire by sending the management server the config
// names and types in initial_configs. Because no state is assumed to be preserved
// from the previous stream, the reconnecting Agent must provide the server with all
// config names and types that it has.
//
// Note that the Agent sends its initial configs also in a antimetal.types.v1.Object
// but it only needs to supply the object name, type, and current version that it has.
// The object data field may be left empty.
//
// Agent                                    Management Server
//
//	|                                           |
//	| [Stream reconnection after failure]      |
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         (instance: same-id)               |
//	|         (last versions: "cfg-v4")         |
//	|                                           |
//	| [Server checks: cfg-v4 != current cfg-v6]|
//	|                                           |
//	|<------- incremental update --------------|
//	|         (seq: "1", version: "cfg-v6")     |
//	|         (only changed configs sent)       |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         (response_seq_num: "1")           |
//
// ```
//
// # Full Example
//
// This comprehensive example demonstrates the full protocol across multiple streams.
//
// ========== STREAM 1 (Agent Startup) ==========
// Agent                                    Management Server
//
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         type: INITIAL                     |
//	|         instance: {id: "agt-abc123"}      |
//	|         supported_collectors: [           | (CPU+MEM capabilities)
//	|           "sys.cpu",                      |
//	|           "sys.mem"                       |
//	|         ]                                 |
//	|         initial_configs: []               | (new agent)
//	|                                           |
//	|<------- first config -------------------|
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v1",                  |
//	|           data: <serialized HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "1"                      |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "1"             |
//	|                                           |
//	|<------- config update ------------------- |
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v2",                  |
//	|           data: <updated HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "2"                      |
//	|                                           |
//	|-------- NACK request -------------------->|
//	|         type: NACK                        |
//	|         response_seq_num: "2"             |
//	|         error_detail: {                   |
//	|           message: "invalid sampling rate"|
//	|         }                                 |
//	|                                           |
//	|<------- corrected config ---------------- |
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v3",                  |
//	|           data: <fixed HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "3"                      |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "3"             |
//	|                                           |
//	| [Agent persists: node-config@v3           |
//	|                                           |
//	|         *** NETWORK INTERRUPTION ***      |
//	|                                           |
//	|                                           |
//
// ========== STREAM 2 (Reconnection) ==========
//
//	|                                           |
//	|-------- INITIAL request ----------------->|
//	|         type: INITIAL                     |
//	|         instance: {id: "agt-abc123"}      | (same agent instance)
//	|         supported_collectors: [           | (same capabilities)
//	|           "sys.cpu",                      |
//	|           "sys.mem"                       |
//	|         ]                                 |
//	|         initial_configs: [{               |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v3"                   | (last known version)
//	|         }]                                |
//	|                                           |
//	|<------- no-op response -------------------|
//	|         configs: []                       | (agent is up-to-date)
//	|         seq_num: "1"                      | ◀── seq number RESETS
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "1"             |
//	|                                           |
//	|         [Time passes...]                  |
//	|                                           |
//	|<------- new config update ----------------|
//	|         configs: [{                       |
//	|           type: {                         |
//	|             type: "antimetal.agent.v1.HostStatsCollectionConfig"
//	|           }                               |
//	|           name: "cpu-stats-config",       |
//	|           version: "v4",                  |
//	|           data: <updated HostStatsCollectionConfig>
//	|         }]                                |
//	|         seq_num: "2"                      |
//	|                                           |
//	|-------- ACK request --------------------->|
//	|         type: ACK                         |
//	|         response_seq_num: "2"             |
//	|                                           |
//	| [Agent persists: node-config@v4           |
type AgentManagementServiceServer interface {
	// WatchConfig establishes a bidirectional streaming connection for configuration
	// management between an Antimetal Agent and the management server.
	//
	// This RPC is long-lived and should remain open for the duration of the agent's
	// lifecycle.
	WatchConfig(grpc.BidiStreamingServer[WatchConfigRequest, WatchConfigResponse]) error
	mustEmbedUnimplementedAgentManagementServiceServer()
}

// UnimplementedAgentManagementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentManagementServiceServer struct{}

func (UnimplementedAgentManagementServiceServer) WatchConfig(grpc.BidiStreamingServer[WatchConfigRequest, WatchConfigResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchConfig not implemented")
}
func (UnimplementedAgentManagementServiceServer) mustEmbedUnimplementedAgentManagementServiceServer() {
}
func (UnimplementedAgentManagementServiceServer) testEmbeddedByValue() {}

// UnsafeAgentManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentManagementServiceServer will
// result in compilation errors.
type UnsafeAgentManagementServiceServer interface {
	mustEmbedUnimplementedAgentManagementServiceServer()
}

func RegisterAgentManagementServiceServer(s grpc.ServiceRegistrar, srv AgentManagementServiceServer) {
	// If the following call pancis, it indicates UnimplementedAgentManagementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentManagementService_ServiceDesc, srv)
}

func _AgentManagementService_WatchConfig_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentManagementServiceServer).WatchConfig(&grpc.GenericServerStream[WatchConfigRequest, WatchConfigResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentManagementService_WatchConfigServer = grpc.BidiStreamingServer[WatchConfigRequest, WatchConfigResponse]

// AgentManagementService_ServiceDesc is the grpc.ServiceDesc for AgentManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "antimetal.service.agent.v1.AgentManagementService",
	HandlerType: (*AgentManagementServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchConfig",
			Handler:       _AgentManagementService_WatchConfig_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "antimetal/service/agent/v1/service.proto",
}
