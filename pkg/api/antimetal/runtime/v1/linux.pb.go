// Antimetal API definitions
// Copyright Antimetal, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: antimetal/runtime/v1/linux.proto

package runtimev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CgroupVersion defines the supported cgroup subsystem versions.
// The cgroup version affects how system resources are managed and monitored.
type CgroupVersion int32

const (
	// CGROUP_VERSION_V1 indicates the legacy cgroup v1 subsystem is in use.
	// This version uses multiple hierarchies with separate controllers.
	CgroupVersion_CGROUP_VERSION_V1 CgroupVersion = 0
	// CGROUP_VERSION_V2 indicates the unified cgroup v2 subsystem is in use.
	// This version provides a single unified hierarchy for all controllers.
	CgroupVersion_CGROUP_VERSION_V2 CgroupVersion = 1
	// CGROUP_VERSION_HYBRID indicates a mixed deployment with both v1 and v2.
	// Some controllers use v1 while others use the v2 unified hierarchy.
	CgroupVersion_CGROUP_VERSION_HYBRID CgroupVersion = 2
)

// Enum value maps for CgroupVersion.
var (
	CgroupVersion_name = map[int32]string{
		0: "CGROUP_VERSION_V1",
		1: "CGROUP_VERSION_V2",
		2: "CGROUP_VERSION_HYBRID",
	}
	CgroupVersion_value = map[string]int32{
		"CGROUP_VERSION_V1":     0,
		"CGROUP_VERSION_V2":     1,
		"CGROUP_VERSION_HYBRID": 2,
	}
)

func (x CgroupVersion) Enum() *CgroupVersion {
	p := new(CgroupVersion)
	*p = x
	return p
}

func (x CgroupVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CgroupVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_runtime_v1_linux_proto_enumTypes[0].Descriptor()
}

func (CgroupVersion) Type() protoreflect.EnumType {
	return &file_antimetal_runtime_v1_linux_proto_enumTypes[0]
}

func (x CgroupVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CgroupVersion.Descriptor instead.
func (CgroupVersion) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_runtime_v1_linux_proto_rawDescGZIP(), []int{0}
}

// CgroupDriver defines the supported cgroup driver implementations.
// The driver affects how cgroups are created, managed, and interfaced with.
type CgroupDriver int32

const (
	// CGROUP_DRIVER_CGROUPFS indicates direct cgroupfs management.
	// This driver directly manipulates cgroup filesystem entries and is
	// typically used in simpler deployments or older systems.
	CgroupDriver_CGROUP_DRIVER_CGROUPFS CgroupDriver = 0
	// CGROUP_DRIVER_SYSTEMD indicates systemd-managed cgroups.
	// This driver integrates with systemd for cgroup lifecycle management
	// and is the preferred approach on systemd-based distributions.
	CgroupDriver_CGROUP_DRIVER_SYSTEMD CgroupDriver = 1
)

// Enum value maps for CgroupDriver.
var (
	CgroupDriver_name = map[int32]string{
		0: "CGROUP_DRIVER_CGROUPFS",
		1: "CGROUP_DRIVER_SYSTEMD",
	}
	CgroupDriver_value = map[string]int32{
		"CGROUP_DRIVER_CGROUPFS": 0,
		"CGROUP_DRIVER_SYSTEMD":  1,
	}
)

func (x CgroupDriver) Enum() *CgroupDriver {
	p := new(CgroupDriver)
	*p = x
	return p
}

func (x CgroupDriver) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CgroupDriver) Descriptor() protoreflect.EnumDescriptor {
	return file_antimetal_runtime_v1_linux_proto_enumTypes[1].Descriptor()
}

func (CgroupDriver) Type() protoreflect.EnumType {
	return &file_antimetal_runtime_v1_linux_proto_enumTypes[1]
}

func (x CgroupDriver) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CgroupDriver.Descriptor instead.
func (CgroupDriver) EnumDescriptor() ([]byte, []int) {
	return file_antimetal_runtime_v1_linux_proto_rawDescGZIP(), []int{1}
}

// Linux contains Linux-specific runtime information reported by agents.
// This information helps the management server optimize configuration
// delivery and ensure compatibility with the agent's runtime environment.
type Linux struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kernel_version is the Linux kernel version string (e.g., "5.4.0-42-generic").
	// This field helps the server understand kernel capabilities and select
	// appropriate collection methods.
	KernelVersion string `protobuf:"bytes,1,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	// cgroup_info provides detailed information about the cgroup subsystem
	// configuration on the Linux system. This includes both the cgroup version
	// (v1, v2, or hybrid) and the driver implementation (cgroupfs or systemd).
	CgroupInfo    *CgroupInfo `protobuf:"bytes,2,opt,name=cgroup_info,json=cgroupInfo,proto3" json:"cgroup_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Linux) Reset() {
	*x = Linux{}
	mi := &file_antimetal_runtime_v1_linux_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Linux) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Linux) ProtoMessage() {}

func (x *Linux) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_runtime_v1_linux_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Linux.ProtoReflect.Descriptor instead.
func (*Linux) Descriptor() ([]byte, []int) {
	return file_antimetal_runtime_v1_linux_proto_rawDescGZIP(), []int{0}
}

func (x *Linux) GetKernelVersion() string {
	if x != nil {
		return x.KernelVersion
	}
	return ""
}

func (x *Linux) GetCgroupInfo() *CgroupInfo {
	if x != nil {
		return x.CgroupInfo
	}
	return nil
}

// CgroupInfo contains detailed information about the cgroup subsystem
// configuration on a Linux system. This information helps the management
// server understand how to interact with container runtimes and system
// resource management.
type CgroupInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// version indicates which cgroup subsystem version is in use.
	// This affects how system resources are organized and controlled.
	Version CgroupVersion `protobuf:"varint,1,opt,name=version,proto3,enum=antimetal.runtime.v1.CgroupVersion" json:"version,omitempty"`
	// driver specifies the cgroup driver implementation being used.
	// Different drivers have different behavioral characteristics and
	// compatibility requirements with container runtimes.
	Driver        CgroupDriver `protobuf:"varint,2,opt,name=driver,proto3,enum=antimetal.runtime.v1.CgroupDriver" json:"driver,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CgroupInfo) Reset() {
	*x = CgroupInfo{}
	mi := &file_antimetal_runtime_v1_linux_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CgroupInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CgroupInfo) ProtoMessage() {}

func (x *CgroupInfo) ProtoReflect() protoreflect.Message {
	mi := &file_antimetal_runtime_v1_linux_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CgroupInfo.ProtoReflect.Descriptor instead.
func (*CgroupInfo) Descriptor() ([]byte, []int) {
	return file_antimetal_runtime_v1_linux_proto_rawDescGZIP(), []int{1}
}

func (x *CgroupInfo) GetVersion() CgroupVersion {
	if x != nil {
		return x.Version
	}
	return CgroupVersion_CGROUP_VERSION_V1
}

func (x *CgroupInfo) GetDriver() CgroupDriver {
	if x != nil {
		return x.Driver
	}
	return CgroupDriver_CGROUP_DRIVER_CGROUPFS
}

var File_antimetal_runtime_v1_linux_proto protoreflect.FileDescriptor

const file_antimetal_runtime_v1_linux_proto_rawDesc = "" +
	"\n" +
	" antimetal/runtime/v1/linux.proto\x12\x14antimetal.runtime.v1\"q\n" +
	"\x05Linux\x12%\n" +
	"\x0ekernel_version\x18\x01 \x01(\tR\rkernelVersion\x12A\n" +
	"\vcgroup_info\x18\x02 \x01(\v2 .antimetal.runtime.v1.CgroupInfoR\n" +
	"cgroupInfo\"\x87\x01\n" +
	"\n" +
	"CgroupInfo\x12=\n" +
	"\aversion\x18\x01 \x01(\x0e2#.antimetal.runtime.v1.CgroupVersionR\aversion\x12:\n" +
	"\x06driver\x18\x02 \x01(\x0e2\".antimetal.runtime.v1.CgroupDriverR\x06driver*X\n" +
	"\rCgroupVersion\x12\x15\n" +
	"\x11CGROUP_VERSION_V1\x10\x00\x12\x15\n" +
	"\x11CGROUP_VERSION_V2\x10\x01\x12\x19\n" +
	"\x15CGROUP_VERSION_HYBRID\x10\x02*E\n" +
	"\fCgroupDriver\x12\x1a\n" +
	"\x16CGROUP_DRIVER_CGROUPFS\x10\x00\x12\x19\n" +
	"\x15CGROUP_DRIVER_SYSTEMD\x10\x01B\xdb\x01\n" +
	"\x18com.antimetal.runtime.v1B\n" +
	"LinuxProtoP\x01ZAgithub.com/antimetal/agent/pkg/api/antimetal/runtime/v1;runtimev1\xa2\x02\x03ARX\xaa\x02\x14Antimetal.Runtime.V1\xca\x02\x14Antimetal\\Runtime\\V1\xe2\x02 Antimetal\\Runtime\\V1\\GPBMetadata\xea\x02\x16Antimetal::Runtime::V1b\x06proto3"

var (
	file_antimetal_runtime_v1_linux_proto_rawDescOnce sync.Once
	file_antimetal_runtime_v1_linux_proto_rawDescData []byte
)

func file_antimetal_runtime_v1_linux_proto_rawDescGZIP() []byte {
	file_antimetal_runtime_v1_linux_proto_rawDescOnce.Do(func() {
		file_antimetal_runtime_v1_linux_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_antimetal_runtime_v1_linux_proto_rawDesc), len(file_antimetal_runtime_v1_linux_proto_rawDesc)))
	})
	return file_antimetal_runtime_v1_linux_proto_rawDescData
}

var file_antimetal_runtime_v1_linux_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_antimetal_runtime_v1_linux_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_antimetal_runtime_v1_linux_proto_goTypes = []any{
	(CgroupVersion)(0), // 0: antimetal.runtime.v1.CgroupVersion
	(CgroupDriver)(0),  // 1: antimetal.runtime.v1.CgroupDriver
	(*Linux)(nil),      // 2: antimetal.runtime.v1.Linux
	(*CgroupInfo)(nil), // 3: antimetal.runtime.v1.CgroupInfo
}
var file_antimetal_runtime_v1_linux_proto_depIdxs = []int32{
	3, // 0: antimetal.runtime.v1.Linux.cgroup_info:type_name -> antimetal.runtime.v1.CgroupInfo
	0, // 1: antimetal.runtime.v1.CgroupInfo.version:type_name -> antimetal.runtime.v1.CgroupVersion
	1, // 2: antimetal.runtime.v1.CgroupInfo.driver:type_name -> antimetal.runtime.v1.CgroupDriver
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_antimetal_runtime_v1_linux_proto_init() }
func file_antimetal_runtime_v1_linux_proto_init() {
	if File_antimetal_runtime_v1_linux_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_antimetal_runtime_v1_linux_proto_rawDesc), len(file_antimetal_runtime_v1_linux_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_antimetal_runtime_v1_linux_proto_goTypes,
		DependencyIndexes: file_antimetal_runtime_v1_linux_proto_depIdxs,
		EnumInfos:         file_antimetal_runtime_v1_linux_proto_enumTypes,
		MessageInfos:      file_antimetal_runtime_v1_linux_proto_msgTypes,
	}.Build()
	File_antimetal_runtime_v1_linux_proto = out.File
	file_antimetal_runtime_v1_linux_proto_goTypes = nil
	file_antimetal_runtime_v1_linux_proto_depIdxs = nil
}
