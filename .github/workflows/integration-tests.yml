name: Tests

# This workflow runs unit tests on the main runner and integration tests across 
# multiple kernel versions using VMs to ensure compatibility with different Linux environments.

on:
  push:
    branches:
      - main
    paths:
      - 'pkg/**'
      - 'internal/**'
      - 'cmd/**'
      - 'ebpf/**'
      - 'test/**'
      - 'Makefile'
      - '.github/workflows/integration-tests.yml'
  pull_request:
    paths:
      - 'pkg/**'
      - 'internal/**'
      - 'cmd/**'
      - 'ebpf/**'
      - 'test/**'
      - 'Makefile'
      - '.github/workflows/integration-tests.yml'
  workflow_dispatch:

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Run unit tests
      run: |
        echo "=== Running Unit Tests ==="
        go test -tags unit ./... -v -coverprofile coverage.out -timeout 30s
    
    - name: Upload coverage
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage.out
        retention-days: 7

  build-artifacts:
    name: Build Test Artifacts
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Install build dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y -qq clang llvm libelf-dev libbpf-dev
    
    - name: Build eBPF programs
      run: |
        echo "Building eBPF programs with CO-RE support..."
        if [ -d ebpf ]; then
          cd ebpf
          if [ ! -f include/vmlinux.h ]; then
            echo "Generating vmlinux.h..."
            ./scripts/generate_vmlinux.sh || {
              echo "Failed to generate vmlinux.h, using fallback..."
              mkdir -p include
              curl -sL https://raw.githubusercontent.com/libbpf/libbpf-bootstrap/master/examples/c/vmlinux.h -o include/vmlinux.h
            }
          fi
          make clean all || echo "eBPF build failed (expected if no eBPF programs yet)"
          cd ..
          
          # Verify BTF sections if any programs were built
          if ls internal/ebpf/*/*.bpf.o 2>/dev/null; then
            echo "=== Verifying BTF support ==="
            for prog in internal/ebpf/*/*.bpf.o; do
              if [ -f "$prog" ]; then
                echo "Checking $(basename $prog):"
                llvm-readelf -S "$prog" | grep -E "BTF|\.BTF\.ext" || echo "No BTF in $prog"
              fi
            done
          fi
        fi
    
    - name: Create integration test runner script
      run: |
        cat > run-integration-tests-in-vm.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "=== System Information ==="
        echo "Kernel: $(uname -r)"
        echo "Architecture: $(uname -m)"
        echo "Go version: $(go version 2>/dev/null || echo 'Go not installed')"
        echo "Date: $(date)"
        
        # Check kernel features
        echo -e "\n=== Kernel Features ==="
        if [ -f /sys/kernel/btf/vmlinux ]; then
          echo "✅ BTF support available"
        else
          echo "⚠️  No BTF support"
        fi
        
        # Check filesystems
        echo -e "\n=== Filesystems ==="
        for fs in /proc /sys /sys/fs/cgroup; do
          if [ -d "$fs" ]; then
            echo "✅ $fs exists"
          else
            echo "❌ $fs missing"
          fi
        done
        
        # Install Go if not present
        if ! command -v go &> /dev/null; then
          echo -e "\nInstalling Go..."
          wget -q https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
          tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
          export PATH=$PATH:/usr/local/go/bin
          rm go1.21.0.linux-amd64.tar.gz
        fi
        
        # Install dependencies
        echo -e "\nInstalling dependencies..."
        apt-get update -qq
        apt-get install -y -qq build-essential git bpftool || true
        
        # Mount BPF filesystem if needed
        if ! mount | grep -q "type bpf"; then
          mount -t bpf bpf /sys/fs/bpf 2>/dev/null || true
        fi
        
        cd /host
        
        # Initialize result counters
        INT_PASS=0
        INT_FAIL=0
        INT_SKIP=0
        
        # Run integration tests only
        echo -e "\n=== Running Integration Tests ==="
        go test -tags integration ./... -v 2>&1 | tee integration-test-results.txt || echo "Integration tests completed with errors"
        
        # Count integration test results
        INT_PASS=$(grep -c "^--- PASS:" integration-test-results.txt 2>/dev/null || echo 0)
        INT_FAIL=$(grep -c "^--- FAIL:" integration-test-results.txt 2>/dev/null || echo 0)
        INT_SKIP=$(grep -c "^--- SKIP:" integration-test-results.txt 2>/dev/null || echo 0)
        
        # Test hardware collectors
        echo -e "\n=== Testing Hardware Collectors ==="
        if [ -d tools/collector-bench ]; then
          cd tools/collector-bench
          go build -o collector-bench main.go
          ./collector-bench -show-data -verbose || echo "Collector bench failed"
          cd ../..
        fi
        
        # Test eBPF programs if they exist
        if ls /host/artifacts/ebpf/*.bpf.o 2>/dev/null; then
          echo -e "\n=== Testing eBPF Programs ==="
          for prog in /host/artifacts/ebpf/*.bpf.o; do
            echo "Loading $(basename $prog)..."
            bpftool prog load "$prog" /sys/fs/bpf/test_prog 2>&1 && {
              echo "✅ $(basename $prog) loaded successfully"
              rm -f /sys/fs/bpf/test_prog
            } || {
              echo "❌ $(basename $prog) failed to load"
            }
          done
        fi
        
        # Generate summary
        echo -e "\n=== Test Summary ==="
        echo "Integration tests: $INT_PASS passed, $INT_FAIL failed, $INT_SKIP skipped"
        
        # Create JSON summary
        cat > test-summary.json << JSON
        {
          "kernel": "$(uname -r)",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "integration_tests": {
            "passed": $INT_PASS,
            "failed": $INT_FAIL,
            "skipped": $INT_SKIP
          }
        }
        JSON
        
        # Exit with failure if any tests failed
        if [ $INT_FAIL -gt 0 ]; then
          exit 1
        fi
        EOF
        chmod +x run-integration-tests-in-vm.sh
    
    - name: Package artifacts
      run: |
        mkdir -p artifacts
        cp run-integration-tests-in-vm.sh artifacts/
        
        # Copy eBPF programs if they exist
        if ls internal/ebpf/*/*.bpf.o 2>/dev/null; then
          mkdir -p artifacts/ebpf
          find internal/ebpf -name "*.bpf.o" -exec cp {} artifacts/ebpf/ \;
        fi
        
        # Create artifact manifest
        echo "Test artifacts:" > artifacts/manifest.txt
        ls -la artifacts/ >> artifacts/manifest.txt
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: test-artifacts
        path: artifacts/
        retention-days: 1

  integration-tests:
    name: Integration Tests - Kernel ${{ matrix.kernel }}
    needs: build-artifacts
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        kernel: ["5.10", "5.15", "6.1", "6.6"]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download test artifacts
      uses: actions/download-artifact@v4
      with:
        name: test-artifacts
        path: artifacts/
    
    - name: Prepare test environment
      run: |
        chmod +x artifacts/run-integration-tests-in-vm.sh
        ls -la artifacts/
    
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Install LVH
      run: |
        go install github.com/cilium/little-vm-helper/cmd/lvh@latest
        echo "$(go env GOPATH)/bin" >> $GITHUB_PATH
    
    - name: Install VM dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y -qq qemu-system-x86 cpu-checker mmdebstrap debian-archive-keyring
        
        # Check virtualization support
        if kvm-ok; then
          echo "KVM acceleration available"
        else
          echo "No KVM - will use software emulation"
        fi
    
    - name: Pull kernel
      run: |
        echo "=== Pulling kernel ${{ matrix.kernel }} ==="
        
        # Pull the kernel
        $(go env GOPATH)/bin/lvh kernels pull ${{ matrix.kernel }}-main || {
          echo "Failed to pull kernel ${{ matrix.kernel }}"
          exit 1
        }
        
        # Find what was downloaded
        echo "Contents after kernel pull:"
        ls -la
        
        # Find the kernel directory
        if [ -d "${{ matrix.kernel }}-main" ]; then
          echo "Found kernel directory: ${{ matrix.kernel }}-main"
          find "${{ matrix.kernel }}-main" -type f | head -10
        fi
    
    - name: Cache VM image
      uses: actions/cache@v4
      id: vm-cache
      with:
        path: vm-images/
        key: vm-image-integration-test-${{ runner.os }}-v3
    
    - name: Build VM image
      if: steps.vm-cache.outputs.cache-hit != 'true'
      run: |
        echo "=== Building VM image ==="
        
        # Create VM images directory
        mkdir -p vm-images
        
        # Create a config file for the VM
        cat > lvh-config.yaml << EOF
        architecture: amd64
        base_image: debian:bookworm
        name: integration-test-vm
        packages:
          - build-essential
          - git
          - wget
          - curl
          - ca-certificates
        EOF
        
        # Build VM image (this creates a rootfs)
        $(go env GOPATH)/bin/lvh images build --dir vm-images -f lvh-config.yaml || {
          echo "Failed to build VM image, trying with default settings..."
          $(go env GOPATH)/bin/lvh images build --dir vm-images
        }
        
        echo "VM image created:"
        ls -la vm-images/
    
    - name: Run tests in VM
      run: |
        echo "=== Running tests in VM with kernel ${{ matrix.kernel }} ==="
        
        # Find the kernel image
        KERNEL=""
        if [ -f "${{ matrix.kernel }}-main/boot/vmlinuz" ]; then
          KERNEL="${{ matrix.kernel }}-main/boot/vmlinuz"
        elif [ -f "${{ matrix.kernel }}-main/vmlinuz" ]; then
          KERNEL="${{ matrix.kernel }}-main/vmlinuz"
        else
          # Try to find any kernel image
          KERNEL=$(find "${{ matrix.kernel }}-main" -name "vmlinuz*" -o -name "bzImage" | head -1)
        fi
        
        if [ -z "$KERNEL" ]; then
          echo "ERROR: Could not find kernel image"
          exit 1
        fi
        
        echo "Using kernel: $KERNEL"
        
        # Find rootfs
        ROOTFS=""
        if [ -f "vm-images/rootfs.img" ]; then
          ROOTFS="vm-images/rootfs.img"
        elif [ -f "vm-images/integration-test-vm.img" ]; then
          ROOTFS="vm-images/integration-test-vm.img"
        else
          ROOTFS=$(find vm-images -name "*.img" | head -1)
        fi
        
        if [ -z "$ROOTFS" ]; then
          echo "ERROR: Could not find rootfs image"
          exit 1
        fi
        
        echo "Using rootfs: $ROOTFS"
        
        # Run the VM with our test script
        $(go env GOPATH)/bin/lvh run \
          --kernel "$KERNEL" \
          --image "$ROOTFS" \
          --host-mount "$PWD:/host" \
          --memory 2G \
          --cpu 2 \
          --timeout 10m \
          -- /host/artifacts/run-integration-tests-in-vm.sh
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.kernel }}
        path: |
          integration-test-results.txt
          test-summary.json
        retention-days: 7

  test-summary:
    name: Test Summary
    needs: [unit-tests, integration-tests]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Summary
      run: |
        echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.unit-tests.result }}" == "success" ]; then
          echo "✅ Unit tests passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Unit tests failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ needs.integration-tests.result }}" == "success" ]; then
          echo "✅ Integration tests passed on all kernel versions" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Integration tests had failures" >> $GITHUB_STEP_SUMMARY
        fi