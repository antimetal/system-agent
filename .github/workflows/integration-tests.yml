name: Tests

# This workflow runs unit tests on the main runner and integration tests across 
# multiple kernel versions using VMs to ensure compatibility with different Linux environments.

on:
  push:
    branches:
      - main
    paths:
      - 'pkg/**'
      - 'internal/**'
      - 'cmd/**'
      - 'ebpf/**'
      - 'test/**'
      - 'Makefile'
      - '.github/workflows/integration-tests.yml'
  pull_request:
    paths:
      - 'pkg/**'
      - 'internal/**'
      - 'cmd/**'
      - 'ebpf/**'
      - 'test/**'
      - 'Makefile'
      - '.github/workflows/integration-tests.yml'
  workflow_dispatch:

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Run unit tests
      run: |
        echo "=== Running Unit Tests ==="
        go test -tags unit ./... -v -coverprofile coverage.out -timeout 30s
    
    - name: Upload coverage
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage.out
        retention-days: 7

  build-artifacts:
    name: Build Test Artifacts
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Install build dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y -qq clang llvm libelf-dev libbpf-dev
    
    - name: Build eBPF programs
      run: |
        echo "Building eBPF programs with CO-RE support..."
        if [ -d ebpf ]; then
          cd ebpf
          if [ ! -f include/vmlinux.h ]; then
            echo "Generating vmlinux.h..."
            ./scripts/generate_vmlinux.sh || {
              echo "Failed to generate vmlinux.h, using fallback..."
              mkdir -p include
              curl -sL https://raw.githubusercontent.com/libbpf/libbpf-bootstrap/master/examples/c/vmlinux.h -o include/vmlinux.h
            }
          fi
          make clean all || echo "eBPF build failed (expected if no eBPF programs yet)"
          cd ..
          
          # Verify BTF sections if any programs were built
          if ls internal/ebpf/*/*.bpf.o 2>/dev/null; then
            echo "=== Verifying BTF support ==="
            for prog in internal/ebpf/*/*.bpf.o; do
              if [ -f "$prog" ]; then
                echo "Checking $(basename $prog):"
                llvm-readelf -S "$prog" | grep -E "BTF|\.BTF\.ext" || echo "No BTF in $prog"
              fi
            done
          fi
        fi
    
    - name: Create integration test runner script
      run: |
        cat > run-integration-tests-in-vm.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "=== System Information ==="
        echo "Kernel: $(uname -r)"
        echo "Architecture: $(uname -m)"
        echo "Go version: $(go version 2>/dev/null || echo 'Go not installed')"
        echo "Date: $(date)"
        
        # Check kernel features
        echo -e "\n=== Kernel Features ==="
        if [ -f /sys/kernel/btf/vmlinux ]; then
          echo "✅ BTF support available"
        else
          echo "⚠️  No BTF support"
        fi
        
        # Check filesystems
        echo -e "\n=== Filesystems ==="
        for fs in /proc /sys /sys/fs/cgroup; do
          if [ -d "$fs" ]; then
            echo "✅ $fs exists"
          else
            echo "❌ $fs missing"
          fi
        done
        
        # Install Go if not present
        if ! command -v go &> /dev/null; then
          echo -e "\nInstalling Go..."
          wget -q https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
          tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
          export PATH=$PATH:/usr/local/go/bin
          rm go1.21.0.linux-amd64.tar.gz
        fi
        
        # Install dependencies
        echo -e "\nInstalling dependencies..."
        apt-get update -qq
        apt-get install -y -qq build-essential git bpftool || true
        
        # Mount BPF filesystem if needed
        if ! mount | grep -q "type bpf"; then
          mount -t bpf bpf /sys/fs/bpf 2>/dev/null || true
        fi
        
        cd /host
        
        # Initialize result counters
        INT_PASS=0
        INT_FAIL=0
        INT_SKIP=0
        
        # Run integration tests only
        echo -e "\n=== Running Integration Tests ==="
        go test -tags integration ./... -v 2>&1 | tee integration-test-results.txt || echo "Integration tests completed with errors"
        
        # Count integration test results
        INT_PASS=$(grep -c "^--- PASS:" integration-test-results.txt 2>/dev/null || echo 0)
        INT_FAIL=$(grep -c "^--- FAIL:" integration-test-results.txt 2>/dev/null || echo 0)
        INT_SKIP=$(grep -c "^--- SKIP:" integration-test-results.txt 2>/dev/null || echo 0)
        
        # Test hardware collectors
        echo -e "\n=== Testing Hardware Collectors ==="
        if [ -d tools/collector-bench ]; then
          cd tools/collector-bench
          go build -o collector-bench main.go
          ./collector-bench -show-data -verbose || echo "Collector bench failed"
          cd ../..
        fi
        
        # Test eBPF programs if they exist
        if ls /host/artifacts/ebpf/*.bpf.o 2>/dev/null; then
          echo -e "\n=== Testing eBPF Programs ==="
          for prog in /host/artifacts/ebpf/*.bpf.o; do
            echo "Loading $(basename $prog)..."
            bpftool prog load "$prog" /sys/fs/bpf/test_prog 2>&1 && {
              echo "✅ $(basename $prog) loaded successfully"
              rm -f /sys/fs/bpf/test_prog
            } || {
              echo "❌ $(basename $prog) failed to load"
            }
          done
        fi
        
        # Generate summary
        echo -e "\n=== Test Summary ==="
        echo "Integration tests: $INT_PASS passed, $INT_FAIL failed, $INT_SKIP skipped"
        
        # Create JSON summary
        cat > test-summary.json << JSON
        {
          "kernel": "$(uname -r)",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "integration_tests": {
            "passed": $INT_PASS,
            "failed": $INT_FAIL,
            "skipped": $INT_SKIP
          }
        }
        JSON
        
        # Exit with failure if any tests failed
        if [ $INT_FAIL -gt 0 ]; then
          exit 1
        fi
        EOF
        chmod +x run-integration-tests-in-vm.sh
    
    - name: Package artifacts
      run: |
        mkdir -p artifacts
        cp run-integration-tests-in-vm.sh artifacts/
        
        # Copy eBPF programs if they exist
        if ls internal/ebpf/*/*.bpf.o 2>/dev/null; then
          mkdir -p artifacts/ebpf
          find internal/ebpf -name "*.bpf.o" -exec cp {} artifacts/ebpf/ \;
        fi
        
        # Create artifact manifest
        echo "Test artifacts:" > artifacts/manifest.txt
        ls -la artifacts/ >> artifacts/manifest.txt
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: test-artifacts
        path: artifacts/
        retention-days: 1

  integration-tests:
    name: Integration Tests - Kernel ${{ matrix.kernel }}
    needs: build-artifacts
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        kernel: ["5.10", "5.15", "6.1", "6.6"]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download test artifacts
      uses: actions/download-artifact@v4
      with:
        name: test-artifacts
        path: artifacts/
    
    - name: Prepare test environment
      run: |
        chmod +x artifacts/run-integration-tests-in-vm.sh
        ls -la artifacts/
    
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
    
    - name: Install LVH
      run: |
        go install github.com/cilium/little-vm-helper/cmd/lvh@latest
        echo "$(go env GOPATH)/bin" >> $GITHUB_PATH
    
    - name: Install VM dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y -qq qemu-system-x86 cpu-checker mmdebstrap debian-archive-keyring
        
        # Check virtualization support
        if kvm-ok; then
          echo "KVM acceleration available"
        else
          echo "No KVM - will use software emulation"
        fi
    
    - name: Pull kernel
      run: |
        echo "=== Pulling kernel ${{ matrix.kernel }} ==="
        
        # Pull the kernel
        $(go env GOPATH)/bin/lvh kernels pull ${{ matrix.kernel }}-main || {
          echo "Failed to pull kernel ${{ matrix.kernel }}"
          exit 1
        }
        
        # Find what was downloaded
        echo "Contents after kernel pull:"
        ls -la
        
        # Find the kernel directory
        if [ -d "${{ matrix.kernel }}-main" ]; then
          echo "Found kernel directory: ${{ matrix.kernel }}-main"
          find "${{ matrix.kernel }}-main" -type f | head -10
        fi
    
    - name: Cache VM image
      uses: actions/cache@v4
      id: vm-cache
      with:
        path: vm-images/
        key: vm-image-integration-test-${{ runner.os }}-v3
    
    - name: Build VM image
      if: steps.vm-cache.outputs.cache-hit != 'true'
      run: |
        echo "=== Building VM image ==="
        
        # Create VM images directory
        mkdir -p vm-images
        
        # Create LVH image configuration
        cat > vm-images/images.json << 'EOF'
        [
          {
            "name": "integration-test",
            "packages": [
              "bpftool",
              "linux-tools-generic",
              "build-essential",
              "git",
              "wget",
              "curl",
              "ca-certificates"
            ],
            "actions": [
              {
                "comment": "Enable root login",
                "op": "run-command", 
                "command": ["sed", "-i", "s/^#PermitRootLogin .*/PermitRootLogin yes/", "/etc/ssh/sshd_config"]
              },
              {
                "comment": "Set root password",
                "op": "run-command",
                "command": ["sh", "-c", "echo 'root:root' | chpasswd"]
              }
            ]
          }
        ]
        EOF
        
        # Build the image
        $(go env GOPATH)/bin/lvh images build --dir vm-images/ || {
          echo "LVH image build failed, downloading pre-built image..."
          # Fallback to a pre-built image
          wget -O vm-images/integration-test.qcow2 https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-amd64.qcow2
          qemu-img resize vm-images/integration-test.qcow2 5G
        }
        
        echo "VM image created:"
        ls -la vm-images/
    
    - name: Run tests in VM
      run: |
        echo "=== Running tests in VM with kernel ${{ matrix.kernel }} ==="
        
        # Find the VM image
        VM_IMAGE=$(find vm-images -name "*.qcow2" -o -name "*.img" | head -1)
        if [ -z "$VM_IMAGE" ]; then
          echo "❌ No VM image found"
          exit 1
        fi
        
        echo "Using VM image: $VM_IMAGE"
        
        # Find the kernel path - LVH downloads to current directory
        KERNEL_PATH=""
        
        # Look for the kernel in the downloaded directory
        if [ -d "${{ matrix.kernel }}-main" ]; then
          # Find vmlinuz file
          KERNEL_PATH=$(find "${{ matrix.kernel }}-main/boot" -name "vmlinuz*" | head -1)
          if [ -z "$KERNEL_PATH" ]; then
            # Try other common kernel file names
            KERNEL_PATH=$(find "${{ matrix.kernel }}-main/boot" -name "bzImage*" -o -name "vmlinux*" | head -1)
          fi
        fi
        
        if [ -n "$KERNEL_PATH" ]; then
          echo "Found kernel at: $KERNEL_PATH"
          # Run with explicit kernel path
          echo "Running: lvh run --kernel $(pwd)/$KERNEL_PATH --image $VM_IMAGE"
          timeout 600 $(go env GOPATH)/bin/lvh run \
            --kernel "$(pwd)/$KERNEL_PATH" \
            --image "$VM_IMAGE" \
            --host-mount $(pwd) \
            -- /host/artifacts/run-integration-tests-in-vm.sh || {
              exit_code=$?
              echo "LVH failed with exit code: $exit_code"
              exit $exit_code
            }
        else
          echo "WARNING: No kernel file found, trying without --kernel flag"
          # Run without kernel flag (use VM's default kernel)
          timeout 600 $(go env GOPATH)/bin/lvh run \
            --image "$VM_IMAGE" \
            --host-mount $(pwd) \
            -- /host/artifacts/run-integration-tests-in-vm.sh || {
            exit_code=$?
            if [ $exit_code -eq 124 ]; then
              echo "❌ Test timed out"
              exit 1
            else
              echo "❌ Test failed with exit code $exit_code"
              exit $exit_code
            fi
          }
        fi
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.kernel }}
        path: |
          integration-test-results.txt
          test-summary.json
        retention-days: 7

  test-summary:
    name: Test Summary
    needs: [unit-tests, integration-tests]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Summary
      run: |
        echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.unit-tests.result }}" == "success" ]; then
          echo "✅ Unit tests passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Unit tests failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ needs.integration-tests.result }}" == "success" ]; then
          echo "✅ Integration tests passed on all kernel versions" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ Integration tests had failures" >> $GITHUB_STEP_SUMMARY
        fi